// For updating subscribe products su_status data use updateSubscribeProductsData() 
var express = require('express');
var router = express.Router();
const verify = require('./verifyToken');
const request = require('request-promise');
const Products = require('../model/Products');
const MainTag = require('../model/MainTag');
const CronStatus = require('../model/CronStatus');
const VarientId = require('../model/VarientId');
const CsvUpload = require('../model/CsvUpload');
const SubscribeProducts = require('../model/SubscribeProducts');
const ShopperrCategory = require('../model/ShopperrCategory');
const Category = require('../model/AllCategory');
const Logs = require('../model/Logs');
const sharp = require('sharp');
const { ReplSet } = require('mongodb');
var mongoose = require('mongoose');
var cron = require('node-cron');
const ObjectsToCsv = require('objects-to-csv');
const csv = require('csvtojson');
const multer = require('multer');
const User = require('../model/User');
const SupplierCode = require('../model/SupplierCode');
const AutoGeneratedSku = require('../model/AutoGeneratedSku');
const UpdatedCategory = require('../model/UpdatedCategory');
const MerchantUser = require('../model/MerchantUser');
var nodemailer = require('nodemailer');
const Po = require("../model/PurchaseOrder");
const purchaseOrder = require("../apps/common/purchaseOrderCron");
const createInvoice = require("../apps/common/createInvoiceCron");
const AWBNumber = require('../model/AWBNumbers')
const { constantValues, mongooseConstantValues } = require("../apps/common/systemConstents")
const createMerchant = require("../apps/common/createMerchant")
const Customer = require('../model/Customer')
const _ = require("lodash")
const ShopperrSubscribeProducts = require('../model/ShopperrSubscribeProducts');
const AmazonSubscribeProducts = require('../model/AmazonSubscribeProducts');
const OtpVerification = require("../model/OtpVerification");
const PriceRule = require('../model/PriceRule');
const DiscountCode = require('../model/DiscountCode');
const axios = require("axios");
const Multipassify = require('multipassify');
const bcrypt = require("bcryptjs");
const Order = require('../model/Orders');
const Hsnmasters = require('../model/Hsnmasters');
const Orderoffshelf = require('../model/Orderoffshelf');
const Offshelfpage = require('../model/Offshelfpage');
const LogisticsLabel = require('../model/LogisticsLabels');
const uploadInventoryCsv = require("../apps/common/csvtoproductscron");
const bulkUploadProduct = require("../apps/common/bulkUploadProductsCron");
const bulkUploadOrder = require("../apps/common/bulkUploadOrdersCron");
const bulkUpdateOrder = require("../apps/common/bulkUpdateOrdersCron");
const updateBarcode = require("../apps/common/updateBarcodeCron");
const updateProductSkusss = require("../apps/common/updateProductSkuCron");
const sfcProductSku = require("../apps/common/updateSfcProductSkuCron");
const promotionalEmail = require("../apps/common/promotionalEmail");
const createAwb = require("../apps/common/createAwbNumber");
const rtoCron = require("../apps/common/rtoCron.js");
const verifyGst = require("../apps/common/verifyGst");
const { messageBuilder  } = require("../apps/common/CommonFunctions")
const offshelfLink = require("../apps/common/offshelfLinkcron");
const pdf2html = require('pdf2html')
const updateTags = require("../apps/common/updateTagsCron");
const updateSupplierProductsTags = require("../apps/common/updateSupplierProductsTagsCron"); 
const { updateShopperrPriceAlgo, getMsrp } = require("../apps/middlewares/priceAlgo")
const jwt = require('jsonwebtoken') 
const Subscriber = require('../model/Subscriber') 
const moment = require('moment-timezone');
ip = require("ip");
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        /* Files will be saved in the 'uploads' directory. Make sure this directory already exists!*/
        cb(null, './uploads');
    },
    filename: (req, file, cb) => {
        const newFilename = `${uuidv4()}${path.extname(file.originalname)}`;
        cb(null, newFilename);
    },
}); 
const { auth } = require('googleapis/build/src/apis/abusiveexperiencereport')

const MainCategory = require('../model/Category');
const BrowseNodes = require('../model/BrowseNodes');

const FCM = require('fcm-node') 

const upload = multer({ storage });
var cronTabRunningStatus = process.env.CRON_TAB_RUN_STATUS;
var invoiceCronTabRunningStatus = process.env.INVOICE_CRON_TAB_RUN_STATUS;
var poTabRunningStatus = process.env.PO_CRON_TAB_RUN_STATUS;
if (invoiceCronTabRunningStatus == 1) {
    cron.schedule("0 */2 * * * *", function () { 
         createInvoice()
         console.log('Invoice cron')
    });
}
if (poTabRunningStatus == 1) {
    cron.schedule("0 */3 * * * *", function () { 
          purchaseOrder()
          console.log('Invoice cron')
    });
}
if (cronTabRunningStatus == 1) {
    cron.schedule("*/1 * * * * *", function () { 
        // console.log('sdsfsghjgh')
        // sfcProductSku()
    });
    cron.schedule("*/5 * * * * *", function () { 
        updateBarcode() 
        // updateJvBarcode()
    });
    cron.schedule('0 */1 * * * *', () => {
        // For updating product price and inventory in shopperr.in store
        updateShopifyVarientCron(); 
        // getShopifyUploadedProductVarientsByTitleCron();
        // updateProductIgstCron();
    });
    cron.schedule('0 */2 * * * *', () => { 
        // For updating product price and inventory in another shopify stores
        updatePriceOnMerchantStoresCron(); 
    });

    cron.schedule('0 */5 * * * *', () => {
        //  ========== Updating product in shopify =============
        // updatePriceOnMerchantStoresCron();
        createAwb()
        updateVariantOnShopify().then(updates => {
            console.log(updates);
        });
    });
    cron.schedule("*/10 * * * * *", function () {
        // console.log("running a task every 10 sec");
        // updateProductIgstCron();
        // updateSupplierProductsTags();
    })
    cron.schedule('*/4 * * * * *', () => {
        //  ========== Add product in shopify =============
        addShopifyProductCronTab(); 
    });
    cron.schedule('0 */1 * * * *', () => {
        //  ========== Change Jv use skus ============= 
        updateProductSkuCron(); 
        //  ========== Create Skus obj ============= 
        updateProductSkusss()
    });
    cron.schedule('*/30 * * * * *', () => {
        //  ========== Update Products tags ============= 
        // updateTags(); 
    });
    cron.schedule('0 */2 * * * *', () => {
        //  ========== Get shopify varients data from shopperr.in ============= 
        getShopifyUploadedProductVarientsCron();
    });
    // console.log('updateSuvStatusCron');
    // updateMetafieldCronTab(); 
    // addShopifyProductCronTab();  
    // updateMerchantProductSubscription();
    // updateProductPriceCronJob(); 
    // updateTagsCronTab();
    // getShopifyVarientDetailCron();  
    // console.log('updateShopifyVarientCron');
    // updateMetafieldCronTab();  
    cron.schedule('0 */5 * * * *', () => {
        // Commented because they are taking things in loop 
        // ==============================  
        addMerchantSubscribedProductCron();
        uploadInventoryCsv()
    });
    // Update tags cron
    cron.schedule('0 */3 * * * *', () => {
        downloadProductCsvCronTab(); 
    });
    cron.schedule('0 */4 * * * *', () => { 
        uploadProductCsvCronTab(); 
    });
    cron.schedule('0 */5 * * * *', () => { 
        bulkUploadProduct();
        // getShopifyRemovedVarientsCron();
    });
    cron.schedule('0 */6 * * * *', () => { 
        updateSuvStatusCron();
        //rtoCron()
    });
    // update Po collection 
     cron.schedule("0 */4 * * * *", function () {
    //     // console.log("running a task every one minute");
          // purchaseOrder()
          // console.log('Invoice cron')
     });
     cron.schedule("0 */2 * * * *", function () {
    //     // console.log("running a task every one minute");
         // createInvoice()
     });
    // cron.schedule("0 */5 * * * *", function () {
    //     // console.log("running a task every five minute");
    //     purchaseOrder();
    // });
    cron.schedule("0 0 1 * * *", function () {
        // console.log("running a task every one hour");
        discountCodeImportCorn();
    });
    // verify gst in merchant login
    // cron.schedule("0 */1 * * * *", function () {
    //     console.log('Running cron !!!')
    //     verifyGst()
    //     purchaseOrder();
    // })
    // cron.schedule("0 */1 * * * *", function () {
    //     uploadInventoryCsv()
    //     rtoCron()
    // });
    // cron.schedule("0 */10 * * * *", function () {
    // getoffshelfCron();
    // });

} else {
    // console.log('Stop Cron');
    // //console.log('Stop Cron');
    // cron.schedule("*/30 * * * * *", function() {
    //     console.log('Running cron !!!')
    //     // verifyGst()
    //     // updatePriceOnMerchantStoresCron();
    // }) 


    // cron.schedule("*/40 * * * * *", function () {
    //     console.log("running a task every minute");
    //     purchaseOrder()
    //     createInvoice()
    //     //assignAWBnumber()
    //     //getTokenFromXB()
    // })

    // cron.schedule('*/15 * * * * *', () => {
    // offshelfLink();
    // updatePriceOnMerchantStoresCron();
    // });
    // cron.schedule('0 */1 * * * *', () => {
    //     getAWBNo()
    // });  
    // cron.schedule("0 */1 * * * *", function () {
    // console.log("schedule running a task every 2 mintues")
    // purchaseOrder()
    // uploadInventoryCsv()
    // rtoCron()
    // })

}
// if (process.env.PO_CRON_STATUS == 1) {
//     cron.schedule("0 */1 * * * *", function () {
//         console.log("schedule running a task every 1 mintues")
//         purchaseOrder()
//         createInvoice()
//     })
// }

//--------------------------AWS SDK for S3-----------------------------------//
var fs = require('fs');
const AWS = require('aws-sdk');
const { result } = require('lodash');
const ID = '';
const SECRET = '';
// The name of the bucket that you have created
const BUCKET_NAME = 'test-bucket';
const s3 = new AWS.S3({
    accessKeyId: ID,
    secretAccessKey: SECRET
});

//File Upload to S3

async function uploadFile(file, key) {
    const params = {
        Bucket: process.env.S3_FILE_BUCKET,
        Key: key, // File name you want to save as in S3
        Body: file,
        ContentType: 'image/jpeg'
    };
    // Uploading files to the bucket
    s3.upload(params, async function (err, data) {
        if (err) {
            throw err;
        }
    });
};  
router.post('/promotionalEmail', async (req, res) => {
    createAwb();
    // createInvoice()
    // downloadProductCsvCronTab();
    // uploadProductCsvCronTab();
    // promotionalEmail();
});
router.post('/bulkUpdateOrder', async (req, res) => {
    bulkUpdateOrder();
});
router.post('/bulkUploadProduct', async (req, res) => {
    bulkUploadProduct();
}); 

router.post('/bulkUploadOrder', async (req, res) => {
    bulkUploadOrder();
}); 

router.post('/updateBarcode', async (req, res) => {
    updateBarcode();
}); 
router.post('/updateProductSkusss', async (req, res) => {
    updateProductSkusss();
}); 
router.post('/purchaseOrder', async (req, res) => {
    purchaseOrder();
});   
router.post('/unsubscribe', async (req, res) => { 
    let token = req.body.id;
    let id = token.slice(5)
    let mingoId = mongoose.Types.ObjectId(id) 
    let emails = await Subscriber.findOne({ _id : mingoId ,  s : 0 }); 
    if(emails){
        let updateVarObj = {
            s : 1
        }
        Subscriber.updateOne({ "_id": mingoId }, { $set: updateVarObj }, { upsert: false }).exec().then(data => {
            res.send({'status' : 1 , 'response' : 'Email Unsubscribed.' })
        }); 
    }else{
        res.send({'status' : 0 , 'response' : 'Invalid Token.' })
    }
});   
router.post('/supplierCode', async (req, res) => {
    var SupplierCountryCode = req.body.countryCode;
    var supplierCode = await SupplierCode.find().sort({ "_id": -1 }).limit(1); 
    if (supplierCode.length > 0) {
        var supplierObj = new SupplierCode({
            spId: mongoose.Types.ObjectId(req.body.supplier),
            spCode: parseInt(supplierCode['0'].spCode + 1),
            scCode: parseInt(SupplierCountryCode),
            date: new Date()
        });
        try {
            var spCode = await supplierObj.save();
            res.send(spCode);
        } catch (err) {
            res.status(400).send(err);
        }
    } else {
        var supplierObj = new SupplierCode({
            spId: mongoose.Types.ObjectId(savedUser._id),
            spCode: parseInt(101),
            scCode: parseInt(SupplierCountryCode),
            date: new Date()
        });
        try {
            var savedSupplier = await supplierObj.save();
            res.send(savedUser);
        } catch (err) {
            res.status(400).send(err);
        }
    }
    // var generatedSku = await generateSku('6021260106e5797d84c9e457');
    // console.log(generatedSku);
});

function generateSku(countryCode, sellierCode) {
    const country = String(countryCode);
    const sellier = String(sellierCode);
    AutoGeneratedSku.count({}, (err, supplierData) => {
        const increment = supplierData + 1;
        const autoGenerated = new AutoGeneratedSku({
            'incNo': increment
        })
        autoGenerated.save(function (err, skudata, [isSaveSuccessful]) {
            if (err) { throw Error(err) }
            if (isSaveSuccessful === 1) {
                const sku = increment + 1000000;
                const finalSku = country + "" + seller + "" + sku;
                return finalSku;
            }
        })
    })
}

async function updateProductSkuCron() {
    var supplierId = mongoose.Types.ObjectId('602fbb6269fea1bd1b71bcbe');
    var products = await Products.find({ upSku: { $exists: false }, "supplier_id": "602fbb6269fea1bd1b71bcbe" }).limit(1);
    if (products.length > 0) {
        updateProductSku(products, 0, supplierId);
    } else {
        console.log('No Product data');
    }
}

async function updateProductSku(products, index, supplierId) {
    console.log("updateProductSku 1 ");
    var product = products[index];
    var updateObj = {
        upSku: 2
    }
    await Products.updateOne({ "_id": product._id }, { $set: updateObj }, { upsert: false }).exec();
    var supplierData = await SupplierCode.find({ "spId": mongoose.Types.ObjectId(supplierId) }).limit(1).exec();
    if (supplierData.length > 0) {
        var supplierCode = supplierData['0'].spCode;
        var supplierCountryCode = supplierData['0'].scCode;
    } else {
        return false;
    }
    const autoskuArr = [];
    let autoGeneratedVal = await AutoGeneratedSku.count();
    autoGeneratedVal = autoGeneratedVal + 1;
    const sku2 = autoGeneratedVal + 1000000;
    const skuval = supplierCountryCode + "" + supplierCode + "" + sku2;
    const autoGenerated = new AutoGeneratedSku({
        'incNo': autoGeneratedVal
    })
    autoskuArr.push(autoGenerated);
    const skus = product.varientArray.map((sku) => {
        autoGeneratedVal = autoGeneratedVal + 1;
        const sku1 = autoGeneratedVal + 1000000;
        const finalSku = supplierCountryCode + "" + supplierCode + "" + sku1;
        const autoGenerated = new AutoGeneratedSku({
            'incNo': autoGeneratedVal
        })
        autoskuArr.push(autoGenerated);
        sku.sku = finalSku;
        return sku;
    })
    await AutoGeneratedSku.insertMany(autoskuArr);
    var updateVarObj = {
        code: skuval,
        varientArray: skus,
        vd: skus,
        upSku: 1,
        productImage : 0
    }
    await Products.updateOne({ "_id": product._id }, { $set: updateVarObj }, { upsert: false }).exec();
    console.log("updateProductSku 2 ");
};


async function uploadExcel(file, key) {
    const params = {
        Bucket: process.env.S3_FILE_BUCKET,
        Key: key, // File name you want to save as in S3
        Body: file
    };
    // Uploading files to the bucket
    s3.upload(params, async function (err, data) {
        if (err) {
            throw err;
        }
        console.log(`File uploaded successfully. ${data.Location}`);
    });
};
router.post('/webservice', function (req, res) {
    // var response = req.body); 
    var productdata = req.body.addProductRequestInfo;
    productdata.forEach(async function (products) {
        try{
	        var categoryTags = [];
	        var sp = '';
	        var sp_id = req.body.HeaderRequest.supplierId;
	        let shippingObj = {
	            method: 'freeShipping',
	        };
	        let stock = {
	            "cn_qty": products.stock.cn_quantity,
	            "in_qty": products.stock.cn_quantity
	        };
	        let prices = {
	            "pd_base_price": products.prices.product_base_price,
	            "ppm_price_2": products.prices.ppm_price_2,
	            "STK_price": products.prices.STK_Shopperr_price
	        };  
	        let FactoryPrice = products.prices.STK_Shopperr_price;
	        sp = chinaPriceAlgo(FactoryPrice, products.product_weight); 
	        handle = await generateHandle(products.pd_name);  
	        let mainImage = [];
	        if(products.tags){
	        	var ptags = products.tags;
	        	categoryTags.push(ptags);
	        }  
	        if (categoryTags.length != 0) {
	            var final_tag = await getTagId(categoryTags.toString());
	            var tgs = categoryTags.toString();
	        } 
	        let productImage = products.productImages; 
	        if (productImage && productImage.length > 0) {
	            productImage.forEach(function (pimage) {
	                var imgData = { 'url': pimage.path, 'handle': handle };
	                var imgpath = '';
	                var varient_id = '';
	                upload_image(imgData, function (result) {
	                    imgpath = result;
	                });
	                var imgres1 = { 'position': (parseInt(pimage.z_status) + 1), 'src': imgpath, 'varient_id': '' }
	                mainImage.push(imgres1);
	            });
	        } 
	        var fprice 	= products.prices.STK_Shopperr_price * 11.50; 
	        let skus  	= []
	        skus.push(products.productID)
	        const data 	= new Products({
	            supplier_id	: sp_id,
	            sid 		: mongoose.Types.ObjectId(sp_id),
	            name 		: products.pd_name,
	            handle 		: handle,  
	            price 		: fprice.toFixed(2),
	            mrp 		: sp.mrp,
	            sp 			: sp.price,
	            cogs 		: sp.cogs,
	            quantity 	: products.stock.in_quantity,
	            weight 		: products.product_weight,
	            description : products.pd_description,
	            code 		: products.productID,
	            skus 		: skus,
	            imgUrl 		: mainImage,
	            uploaded_on : Date(),
	            size 		: products.product_height,
	            shippingCharge: shippingObj,
	            tags 		: final_tag,
	            category 	: '',
	            cat_id 		: products.category_id,
	            pd_model 	: products.product_model,
	            pd_brand 	: products.brand,
	            pd_visible 	: products.product_visible,
	            pd_pack_unit: products.product_pack_unit,
	            length 		: products.product_length,
	            width 		: products.product_width,
	            height 		: products.product_height,
	            g_id 		: products.g_id,
	            gst 		: products.gst,
	            pd_sum 		: products.product_sum,
	            pd_manage_status: products.product_manage_status,
	            pd_status 	: products.product_status,
	            pd_location : products.product_location,
	            is_display 	: products.is_display,
	            is_delete 	: products.is_delete,
	            stock 		: stock,
	            prices 		: prices,
	            tgs 		: tgs
	        }); 
	        var pduplicate = await getProductDataBySku(products.productID);
	        try {
	            if (pduplicate && pduplicate.length > 0) {
	                console.log('Duplicate Product'); 
	            } else {
	                const newProduct = data.save();
	                console.log('Product Added Successfully'); 
	            }
	        } catch (error) {
	            console.log(error);
	        }
	    } catch (error) {
            console.log(error.toString());
        }
    });
    res.send({ status: 200, msg: 'Product Added Successfully' });
})

function generateHandle(title) {
    return new Promise((resolve, reject) => {
        var data = title.trim(); 
        var final_str = data.toLocaleLowerCase().replace(/[^\w-]+/g,"-")
        var handle = Products.findOne({ "handle": final_str }).exec().then(product => {
            if (product == '') {
                return final_str;
            } else {
                return final_str + '-' + Date.now().toString();
            }
        });
        resolve(handle);
    })
}

function getProductDataBySku(cond) {
    return new Promise((resolve, reject) => {
        try {
            let productData = Products.find({ 'code': cond });
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

function gettagsById(tags) {
    return new Promise(function (resolve, reject) {
        tagArr = []
        if (tags) {
            var tagsArray = tags;
            const promises = [];
            for (i = 0; i < tagsArray.length; i++) {
                var tag = tagsArray[i];
                promises.push(getTags(tag))
            }
            Promise.all(promises).then(tagArr => {
                // console.log(tagArr);
                resolve(tagArr);
            }).catch((e) => {
                // handle errors here
            });
        }
    })
}

function getTags(tag) {
    return new Promise(function (resolve, reject) {
        MainTag.find({ '_id': tag }).exec().then(if_tag => {
            if (if_tag) {
                if (if_tag[0]) {
                    resolve(if_tag[0].tag);
                }
            }
        })
    })
}
router.post('/cronStatus', async (req, res) => {
    const cronStatus = await new CronStatus({
        cId: req.body.cId,
        cName: req.body.cName,
        status: req.body.status
    });
    // console.log(req.body); return false;
    try {
        const saveCron = await cronStatus.save();
    } catch (err) {
        res.status(400).send(err);
        console.log(err);
    }
});


router.post('/updatePrice/:supplier_id', async (req, res) => {
    var limit = req.body.limit;
    let products = await Products.find({ supplier_id: req.params.supplier_id }).limit(parseInt(limit));
    if (products.length > 0) {
        updateProducts(products, 0);
    }
});
async function updateProductPriceCronJob() {
    var limit = 500;
    var supplier_id = '5ff1fb6cb5a4c4a27a0580dd';
    let products = await Products.find({ supplier_id: supplier_id, cogs: { $exists: false } }).limit(parseInt(limit));
    if (products.length > 0) {
        updateProducts(products, 0);
    }
}

async function updateProducts(products, index) {
    if (products.length < index + 1) {
        return false;
    }
    var product = products[index];
    var categoryTags = await getCategoryTags(product.description);
    var tag = '';
    var tgs = '';
    if (categoryTags.length != 0) {
        tag = await getTagId(categoryTags.toString());
        tgs = categoryTags.toString();
    }
    if (product.weight != '' && product.prices.STK_price != '') {
        var price = chinaPriceAlgo(product.prices.STK_price, product.weight);
        let obj = {
            price: (product.prices.STK_price * 11.50).toFixed(2),
            mrp: price.mrp,
            sp: price.price,
            cogs: price.cogs,
            tags: tag,
            tgs: tgs
        }
        // console.log(obj); return false;

        const data = await Products.updateOne({ _id: product._id }, { $set: obj }, { upsert: false }).then(data => {
            updateProducts(products, ++index);
        });
    } else {
        updateProducts(products, ++index);
    }

}
async function updateMerchantProductSubscription() {
    var limit = 50000;
    var merchant = '600d67ca51b296e894178f3c';
    var supplier_id = '5ff1fb6cb5a4c4a27a0580dd';
    let products = await Products.find({ supplier_id: supplier_id }, { _id: 1 }).limit(parseInt(limit));
    if (products.length > 0) {
        products.forEach(async function (product) {
            const subscribeProducts = await new SubscribeProducts({
                mId: mongoose.Types.ObjectId(merchant),
                pId: product._id,
                dos: new Date(),
                dom: new Date()
            });
            try {
                const saveProduct = await subscribeProducts.save();
                console.log("Prosuct Saved", saveProduct);
            } catch (err) {
                res.status(400).send(err);
                console.log(err);
            }
        });
    }
}


// router.post('/shopifySubscribedProduct/:supplier_id', async (req, res) => { 
async function getShopifyVarientDetailCron() {
    var supplier_id = '602fbb6269fea1bd1b71bcbe';
    var merchant_id = '600d67ca51b296e894178f3c';
    // var supplier_id = '602f8a26c69fd3abcc411da5';
    // var merchant_id = '60095d4e9e8dd0bc997ad9a1';  
    let products = await Products.find({ supplier_id: supplier_id, varStatus: 1 }).sort({ "_id": -1 }).limit(1);
    return false;
    if (products.length > 0) {
        getShopifyVarientDetail(products, merchant_id, 0);
    } else {
        console.log('No Products');
    }
}

// router.post('/shopifySubscribedProduct', async (req, res) => { 
async function getShopifyUploadedProductVarientsCron() {
    var products = await SubscribeProducts.find({ "mId": mongoose.Types.ObjectId("600d67ca51b296e894178f3c"), error_status: 2, su_status: 1 }).limit(1);
    if (products.length > 0 && products[0].spId != undefined) {
        let updateObj = {
            error_status: 4
        }
        let udata = await SubscribeProducts.updateOne({ "_id": products[0]._id }, { $set: updateObj }, { upsert: false });
        let merchantCond = { "_id": products[0].mId };
        let merchantData = await getMerchantData(merchantCond, 1);
        let merchantInfo = merchantData[0].storeData[0];
        if (merchantInfo) {
            let productArray = await getProductData(mongoose.Types.ObjectId(products[0].pId), 1);
            let product = productArray[0];
            request.get("https://" + merchantInfo.shopifyApiKey + ":" + merchantInfo.shopifySecretKey + "@" + merchantInfo.storeDomain + "/admin/api/2021-04/products/" + products[0].spId + ".json")
                .then(async (data) => {
                    var data = JSON.parse(data);
                    if (!data.product) { 
                        return;
                    }
                    data = data.product;
                    var varientArray = [];
                    if (data.variants.length > 0) {
                        data.variants.forEach(function (varient) {
                            var varientObj = product.varientArray.find((item) => {
                                return item.varient == varient.title;
                            });
                            var newVarientObj = {};
                            if (varientObj) {
                                newVarientObj = {
                                    spvid: varient.id,
                                    ssvid: varientObj.varient_id,
                                };
                                varientArray.push(newVarientObj);
                            } else {
                                newVarientObj = {
                                    spvid: varient.id,
                                };
                                varientArray.push(newVarientObj);
                            }
                        });
                    }
                    var updateVariant = {};
                    if (data.images.length > 0) {
                        updateVariant = {
                            vd: varientArray,
                            suv_status: 0,
                            error_status: 1
                        }
                    } else {
                        updateVariant = {
                            vd: varientArray,
                            suv_status: 0,
                            img_status: 1,
                            error_status: 1
                        }
                    }
                    try {
                        var updata = await SubscribeProducts.updateOne({ "_id": products[0]._id }, { $set: updateVariant }, { upsert: false });
                    } catch (err) {
                        console.log(err);
                    }
                });
        }
    }
};

async function getShopifyRemovedVarientsCron() {
    var products = await SubscribeProducts.find({ error_status: 3, su_status: 1 }).limit(1);
    // var products = await SubscribeProducts.find({ "spId" : 6537073098892}).limit(1);
    if (products.length > 0 && products[0].spId != undefined) {
        let updateObj = {
            error_status: 2
        }
        let udata = await SubscribeProducts.updateOne({ "_id": products[0]._id }, { $set: updateObj }, { upsert: false });
        // console.log(products); return false; 
        let merchantCond = { "_id": products[0].mId };
        let merchantData = await getMerchantData(merchantCond, 1);
        let merchantInfo = merchantData[0].storeData[0];
        if (merchantInfo) {
            let productArray = await getProductData(mongoose.Types.ObjectId(products[0].pId), 1);
            let product = productArray[0];
            request.get("https://" + merchantInfo.shopifyApiKey + ":" + merchantInfo.shopifySecretKey + "@" + merchantInfo.storeDomain + "/admin/api/2021-04/products/" + products[0].spId + ".json")
                .then(async (data) => {
                    var data = JSON.parse(data);
                    if (!data.product) {
                        return;
                    }
                    data = data.product;
                    var varientArray = [];
                    if (data.variants.length > 0) {
                        data.variants.forEach(function (varient) {
                            var varientObj = product.varientArray.find((item) => {
                                return item.varient == varient.title;
                            });
                            var newVarientObj = {};
                            if (varientObj) {
                                newVarientObj = {
                                    spvid: varient.id,
                                    ssvid: varientObj.varient_id,
                                };
                                varientArray.push(newVarientObj);
                            } else {
                                newVarientObj = {
                                    spvid: varient.id,
                                };
                                varientArray.push(newVarientObj);
                            }
                        });
                    }
                    var updateVariant = {};
                    if (data.images.length > 0) {
                        updateVariant = {
                            vd: varientArray,
                            suv_status: 0,
                            error_status: 1
                        }
                    } else {
                        updateVariant = {
                            vd: varientArray,
                            suv_status: 0,
                            img_status: 1,
                            error_status: 1
                        }
                    }
                    console.log(updateVariant, products[0]._id, products[0]);
                    try {
                        var updata = await SubscribeProducts.updateOne({ "_id": products[0]._id }, { $set: updateVariant }, { upsert: false });
                        console.log(updata, '112212', products[0]._id);
                    } catch (err) {
                        console.log(err);
                    }
                });
        }
    }
};
async function getShopifyVarientDetail(products, merchant, index) {
    let product = products[index];
    let updateObj = {
        varStatus: 4
    }
    let udata = await Products.updateOne({ "_id": product._id }, { $set: updateObj }, { upsert: false }).exec();

    // console.log(udata , product._id);   return false;
    request.get("https://0e69dc16490d890edafb56bb5555afe4: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@shopperr2.myshopify.com/admin/api/2021-01/products.json?title=" + product.name.replace("&", "%26"))
        .then(async (data) => {
            var data = JSON.parse(data);
            console.log(data.products.length, product.name.replace("&", "%26"));
            if (!data.products || !data.products.length) {
                return;
            }
            data = data.products[0];
            var subProduct = await SubscribeProducts.find({ pId: product._id, mId: mongoose.Types.ObjectId(merchant) }).limit(1);
            var varientArray = [];
            if (data.variants.length > 0) {
                data.variants.forEach(function (varient) {
                    var varientObj = product.varientArray.find((item) => {
                        return item.varient == varient.title;
                    });
                    var newVarientObj = {};
                    if (varientObj) {
                        newVarientObj = {
                            spvid: varient.id,
                            ssvid: varientObj.varient_id,
                        };
                        varientArray.push(newVarientObj);
                    } else {
                        newVarientObj = {
                            spvid: varient.id,
                        };
                        varientArray.push(newVarientObj);
                    }
                });
            }
            if (subProduct.length == 0) {
                const subscribeProducts = await new SubscribeProducts({
                    mId: mongoose.Types.ObjectId(merchant),
                    pId: product._id,
                    spId: data.id,
                    vd: varientArray,
                    su_status: 1,
                    suv_status: 0,
                    dos: new Date(),
                    dom: new Date()
                });
                try {
                    const saveProduct = await subscribeProducts.save();
                    var updateStatus = {
                        varStatus: 2
                    }
                    var updata = await Products.updateOne({ "_id": product._id }, { $set: updateStatus }, { upsert: false }).exec();
                } catch (err) {
                    console.log(err);
                }
            } else {
                try {
                    var updateVariant = {
                        spId: data.id,
                        vd: varientArray,
                        su_status: 1,
                        suv_status: 0
                    }
                    var updata = await SubscribeProducts.updateOne({ "_id": subProduct[0]._id }, { $set: updateVariant }, { upsert: false }).exec();

                    var updateProductStatus = {
                        varStatus: 2
                    }
                    var updateProductData = await Products.updateOne({ "_id": product._id }, { $set: updateProductStatus }, { upsert: false }).exec();
                    console.log(updata, 'data2222');
                } catch (err) {
                    console.log(err);
                }
            }
        });
}
// db.products.createIndex({ supplier_id: 1, pd_manage_status: 1, pd_status: 1 , is_display:1})

router.post('/SubscribedProduct/:supplier_id', async (req, res) => { 
    for(let i = 500 ; i < 600; i++){
        let skip = i*100;  
        const merchant = req.body.merchant;
        let products = await  Products.find({"supplier_id" : req.params.supplier_id , "pd_manage_status" : "1","pd_status" : "1","is_display" : "1"} , {_id : 1}).sort({_id : 1}).skip(skip).limit(100);
        // let products = await Products.find({ "supplier_id": req.params.supplier_id }, { _id: 1 }).sort({ _id: -1 }); 1350
        if (products.length > 0) {
            var subscribeProductList = [];
            var counter = 0;
            // var y = 0;
            // var z = 0; 
            products.forEach(async function (product, index) {
                let getProductCond = {
                    pId: product._id,
                    mId: mongoose.Types.ObjectId(merchant)
                };
                var subProduct = await getSubscribeProductData(getProductCond, 1);
                if (subProduct.length == 0) {
                    var subscribeProducts = await new SubscribeProducts({
                        mId: mongoose.Types.ObjectId(merchant),
                        pId: product._id,
                        dos: new Date(),
                        dom: new Date()
                    });
                    subscribeProductList.push(subscribeProducts);
                    counter = counter + 1;
                } else {
                    console.log("error Saved");
                } 
                if (counter == 50) { 
                    let insertStatus = await insertSubscribeProduct(subscribeProductList);
                    console.log('insertStatus'); 
                    counter = 0;
                    subscribeProductList = [];
                } else {
                    console.log(counter, 'counter');
                }

            });
        } else {
            res.send("Product Not found");
        }
    }
});

function getSubscribeProductData(cond, limit) {
    return new Promise((resolve, reject) => {
        try {
            let productData = SubscribeProducts.find(cond).limit(limit);
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

function getShopperSubscribeProductData(cond, limit) {
    return new Promise((resolve, reject) => {
        try {
            let productData = ShopperrSubscribeProducts.findOne(cond);
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

function insertSubscribeProduct(data) {
    return new Promise((resolve, reject) => {
        try {
            var insertedData = SubscribeProducts.insertMany(data);
            resolve(insertedData);
        } catch (err) {
            return true;
        }
    })
}

function getProductData(cond) {
    return new Promise((resolve, reject) => {
        try {
            let productData = Products.find({ '_id': cond });
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

function getMerchantDetails(id) {

}

// async function updateShopifyVarientCron(){
//     // var merchant = '600d67ca51b296e894178f3c';
//     // var merchant = '60095d4e9e8dd0bc997ad9a1';
//     let products = await SubscribeProducts.find({ $and: [{"su_status" : 1} , {"suv_status" : 0}, { mId: mongoose.Types.ObjectId("600d67ca51b296e894178f3c") }]}).sort({_id : -1}).limit(1);
//     // let products = await SubscribeProducts.find({ spId :5258964467852 }).sort({_id : -1}).limit(1);

//     if(products.length > 0){ 
//         var product =  products[0];  
//         var cond = {"_id" : product._id };
//         let updateObj = {  
//             suv_status: 2
//         }  
//         var dataup = await updateSubscribeProducts(cond , updateObj);    
//         let productArray = await Products.find({_id: product.pId }).limit(1);   
//         if(productArray.length > 0){
//             productArray = productArray[0]; 
//             var productStatus = 'draft'
//             if(productArray.quantity > 0){
//                 productStatus = 'active'
//             } 
//             var imgUrls = productArray.imgUrl;
//             var finalImgUrl = imgUrls.map(function (imgUrl) {
//                 var imgSrc = {
//                     "position" : imgUrl.position,
//                     "src" : process.env.S3_BUCKET_FILE_URL+'/'+imgUrl.src
//                 } 
//                 return imgSrc 
//             });
//             // console.log(finalImgUrl);  return false;
//             let isSupplier = productArray.supplier_id == "5ff1fb6cb5a4c4a27a0580dd" ? 1 : 0;
//             var suppliers = await User.find({_id : mongoose.Types.ObjectId(productArray.supplier_id)}).limit(1); 
//             let suppllierOrigin = '';
//             if(suppliers.length > 0){
//                 suppllierOrigin = suppliers[0].price_algo;
//             }
//             var fp = ''; 
//             var pw = '';
//             var pbcd = '';
//             var pigst = '';
//             var pswc = '';
//             var mrps = '';
//             var lenght = '';
//             var width = '';
//             var height = '';
//             fp = (productArray['price'] != undefined) ? productArray['price'] : 0;
//             mrps = (productArray.mrp != undefined) ? productArray.mrp : 0;
//             pw = (productArray.weight != undefined) ? productArray.weight : 0;
//             lenght = ( productArray.length != undefined) ? productArray.length : 0;
//             width = (productArray.width != undefined) ? productArray.width : 0;
//             height = (productArray.height != undefined) ? productArray.height : 0;
//             pbcd = (productArray.bcd != undefined) ? productArray.bcd : 10; 
//             pigst = (productArray.igst != undefined) ? productArray.igst : 18;
//             margin = (productArray.productMargin != undefined) ? productArray.productMargin : 40;
//             pswc = (productArray['swcOnBcd'] != undefined) ? productArray['swcOnBcd'] : 10;
//             var sp = await updateShopperrPriceAlgo(Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , lenght , width , height , mrps , margin); 
//             // console.log(Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , lenght , width , height , mrps , sp); return false; 
//             var variants = [];
//             product.vd.forEach(async function(varient){
//                 var varientObj = productArray.varientArray.find((item)=>{
//                     if(varient.ssvid != undefined){
//                         return (item.varient_id.toString().replace(' ','') == varient.ssvid.toString().replace(' ',''));
//                     } 
//                 });
//                 if(varientObj) {
//                     let variantPrice = (product.margin != undefined) ? Number(varientObj.sp) + (varientObj.sp*product.margin/100) : varientObj.sp;
//                     let compare_at_price = parseFloat(varientObj.mrp);
//                     let cogs = parseFloat(varientObj.cogs);
//                     if(isSupplier){
//                         fp = (varientObj['price'] != '' && varientObj['price'] != 'undefined') ? varientObj['price'] : 0;
//                         mrps = (varientObj.mrp != '' && varientObj.mrp != 'undefined') ? varientObj.mrp : 0;
//                         var vsp = await updateShopperrPriceAlgo(Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , lenght , width , height , mrps , margin); 
//                         variantPrice = parseFloat(vsp.airPrice.price);
//                         compare_at_price = parseFloat(vsp.airPrice.mrp);
//                         cogs = parseFloat(vsp.airPrice.cogs);
//                     }
//                     let newVarientObj = {
//                         id : varient.spvid,
//                         price : variantPrice,
//                         sku : varientObj.sku, 
//                         compare_at_price: (product.mId != '600d67ca51b296e894178f3c') ? compare_at_price*2 : compare_at_price, 
//                         cost :cogs,
//                         inventory_quantity: varientObj.quantity,
//                         weight: productArray.weight,
//                         weight_unit: "g",
//                     };
//                     variants.push(newVarientObj);
//                 }
//             }); 
//             var newProductObj = "";
//             if(variants.length != 0){ 
//                 newProductObj = {
//                     id: product.spId,
//                     title: productArray.name, 
//                     status: productStatus, 
//                     variants : variants,
//                 } 
//             }else{
//                 // console.log(sp);
//                 let productPrice = (product.margin != undefined) ? productArray.sp + (productArray.sp*product.margin/100) : productArray.sp;
//                 let compare_at_price = parseFloat(productArray.mrp);
//                 let cogs = parseFloat(productArray.cogs);
//                 if(isSupplier){
//                     productPrice = parseFloat(sp.airPrice.price);
//                     compare_at_price = parseFloat(sp.airPrice.mrp);
//                     cogs = parseFloat(sp.airPrice.cogs);
//                 }
//                 let newVarientObj = {
//                     id : product.vd[0].spvid,
//                     sku : productArray.code,
//                     price: productPrice,
//                     compare_at_price: (product.mId != '600d67ca51b296e894178f3c') ? compare_at_price*2 : compare_at_price,
//                     inventory_quantity: productArray.quantity,
//                     cost:cogs,
//                     weight: productArray.weight,
//                     weight_unit: "g",
//                 };
//                 variants.push(newVarientObj);
//                 newProductObj = {
//                     id: product.spId,
//                     title: productArray.name, 
//                     status: productStatus,  
//                     variants : variants,
//                 } 
//             } 
//             console.log(newProductObj);  
//             let merchantCond = {"_id" : product.mId };
//             let merchantData = await getMerchantData(merchantCond , 1);
//             let merchantSingleData = merchantData[0];
//             let merchantStoreData = merchantSingleData.storeData[0]; 
//             const shopRequestUrl = 'https://'+merchantStoreData.storeDomain+'/admin/api/2021-01/products/'+product.spId+'.json'; 
//             const shopRequestHeaders = {
//                 'X-Shopify-Access-Token': merchantStoreData.shopifySecretKey,
//                 'Content-Type': 'application/json', 
//                 'X-Shopify-Hmac-Sha256': merchantStoreData.shopifyApiKey,
//                 'X-Shopify-Shop-Domain': merchantStoreData.storeDomain, 
//                 'X-Shopify-API-Version': '2021-01',
//             }; 
//             // console.log(shopRequestUrl , product.spId); return false;
//             var productUpdateStatus = await updateShopifyProductApi(shopRequestUrl , shopRequestHeaders , newProductObj , product._id);
//             // console.log(productUpdateStatus , product.spId , productUpdateStatus.product.images.length);  
//             if(productUpdateStatus.product.id){
//                 try{
//                     let cond = {"_id" : product._id };
//                     let obj = {  
//                         suv_status: 1 
//                     }                   
//                     const data = await updateSubscribeProducts(cond , obj);                        
//                     console.log('Product Updated Success' , data , productUpdateStatus.product.id , productUpdateStatus.product.images.length);  
//                 }catch(error){
//                     console.log(error);
//                 }
//                 if(productUpdateStatus.product.images.length == 0){
//                     if(finalImgUrl.length != 0){
//                         newProductImgObj = {
//                             id: product.spId, 
//                             images: finalImgUrl
//                         } 
//                         var productUpdateImages = await updateShopifyProductApi(shopRequestUrl , shopRequestHeaders , newProductImgObj , product._id);
//                         if(productUpdateImages.product.id){
//                             try{
//                                 let cond = {"_id" : product._id };
//                                 let obj1 = {  
//                                     img_status: 0 
//                                 }                   
//                                 const data1 = await updateSubscribeProducts(cond , obj1);                        
//                                 console.log('Product Image Updated Success' , data1 );  
//                             }catch(error){
//                                 console.log(error);
//                             }
//                         } 
//                     }
//                 } 
//             } 
//         }

//     }else{
//         console.log('No Product');
//     }
// }; 

async function updatePriceOnMerchantStoresCron() {
    // let products = await SubscribeProducts.find({ '_id' :mongoose.Types.ObjectId("611e01b518e7cb220feda13f") }).sort({_id : -1}).limit(1);
    let products = await SubscribeProducts.find({ $and: [{ "su_status": 1 }, { "suv_status": 0 }, { mId: { $ne: mongoose.Types.ObjectId("600d67ca51b296e894178f3c") } } , { is_vup: { $ne: 1 }}] }).sort({ _id: -1 }).limit(10);
    if (products.length > 0) {
        var subscribeProductIds = products.map(function (id) { return id._id });
        var productIds = products.map(function (id) { return id.pId });
        let updateObj = {
            suv_status: 2
        }
        var dataup = await SubscribeProducts.updateMany({ "_id": { $in: subscribeProductIds } }, { $set: updateObj }, { upsert: false });
        let productArrays = await Products.find({ _id: { $in: productIds } });
        if (productArrays.length > 0) {
            const updates = (await Promise.all(productArrays.map((productArray) => {
                return (new Promise(async (resolve, reject) => {
                    var product = '';
                    product = products.find((item) => { return item.pId == productArray._id.toString() });
                    if (product == -1) {
                        resolve({ 'error': 1, 'Message': 'Products Not found' });
                        return false;
                    }
                    var productStatus = 'draft'
                    if (productArray.quantity > 0 ) {
                        productStatus = 'active'
                    }
                    var imgUrls = productArray.imgUrl;
                    var finalImgUrl = imgUrls.map(function (imgUrl) {
                        var imgSrc = {
                            "position": imgUrl.position,
                            "src": process.env.S3_BUCKET_FILE_URL + '/' + imgUrl.src
                        }
                        return imgSrc
                    });
                    let suppliers = await User.findOne({ _id: mongoose.Types.ObjectId(productArray.supplier_id) });
                    let suppllierOrigin = '';
                    if (suppliers) {
                        suppllierOrigin = suppliers.price_algo;
                    }
                    let fp = (productArray['price'] != undefined) ? productArray['price'] : 0;
                    let mrps = (productArray.mrp != undefined) ? productArray.mrp : 0;
                    let pw = (productArray.weight != undefined) ? productArray.weight : 0;
                    let length = (productArray.length != undefined) ? productArray.length : 0;
                    let width = (productArray.width != undefined) ? productArray.width : 0;
                    let height = (productArray.height != undefined) ? productArray.height : 0;
                    let pbcd = (productArray.bcd != undefined) ? productArray.bcd : 10;
                    let pigst = (productArray.igst != undefined) ? productArray.igst : 18;
                    let margin = (productArray.productMargin != undefined) ? productArray.productMargin : 40;
                    let pswc = (productArray['swcOnBcd'] != undefined) ? productArray['swcOnBcd'] : 10;
                    let sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, length, width, height, mrps, margin);
                    // console.log(Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , length , width , height , mrps , sp);   
                    // var variants = [];
                    let variants = (await Promise.all(product.vd.map((varient) => {
                        return (new Promise(async (resolve, reject) => {
                            var varientObj = productArray.varientArray.find((item) => {
                                if (varient.ssvid != undefined) {
                                    return (item.varient_id.toString().replace(' ', '') == varient.ssvid.toString().replace(' ', ''));
                                }
                            });
                            if (!varientObj) {
                                resolve({ 'error': 1, 'message': 'Product varient not matched.' });
                                return false;
                            }
                            let variantPrice = '';
                            let compare_at_price = '';
                            let cogs = '';
                            let variantcogs = '';
                            let msrp = '';
                            fp = (varientObj['price'] != '' && varientObj['price'] != 'undefined') ? varientObj['price'] : 0;
                            mrps = (varientObj.mrp != '' && varientObj.mrp != 'undefined') ? varientObj.mrp : 0;
                            var vsp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, length, width, height, mrps, margin);
                            // console.log(vsp);
                            variantPrice = (product.margin != undefined) ? Number(vsp.airPrice.price) + (vsp.airPrice.price * product.margin / 100) : vsp.airPrice.price;
                            compare_at_price = parseFloat(vsp.airPrice.mrp);
                            cogs = parseFloat(vsp.airPrice.cogs);
                            msrp = getMsrp(compare_at_price);
                            variantcogs = vsp.airPrice.price;
                            let finalcompareprice = (product.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price;
                            if(product.mId == '611dd6963f897a8f2921d8fa'){
                                variantcogs = fp
                                variantPrice = (product.margin != undefined) ? Number(fp) + (fp * product.margin / 100) : fp
                                finalcompareprice = getMsrp(fp)
                            }

                            if(product.channel == 'ds'){
                                variantcogs = vsp.dropshipperPrice.price
                                variantPrice = (product.margin != undefined) ? Number(vsp.dropshipperPrice.price) + (vsp.dropshipperPrice.price * product.margin / 100) : vsp.dropshipperPrice.price;
                                compare_at_price = parseFloat(vsp.dropshipperPrice.mrp);
                                finalcompareprice = (product.mId != '600d67ca51b296e894178f3c') ? getMsrp(compare_at_price) : compare_at_price;
                            }

                            let newVarientObj = {
                                id: varient.spvid,
                                price: Math.ceil(variantPrice),
                                sku: varientObj.sku,
                                compare_at_price: (productArray.pmrp) ? productArray.pmrp : finalcompareprice,
                                cost: (product.mId != '600d67ca51b296e894178f3c') ? variantcogs : cogs,
                                inventory_quantity: varientObj.quantity,
                                weight: productArray.weight,
                                weight_unit: "g",
                            };
                            resolve(newVarientObj);
                        }));
                    })).then((data) => data).catch((err) => err));
                    variants = variants.filter((variant) => {
                        if (variant.error == 1) {
                            return false;
                        }
                        return true;
                    });
                    var newProductObj = "";
                    if (variants.length != 0) {
                        newProductObj = {
                            id: product.spId,
                            title: productArray.name,
                            status: productStatus,
                            body_html : productArray.description,
                            variants: variants,
                        }
                    } else {
                        let productPrice = ''
                        let compare_at_price = '';
                        let cogs = '';
                        let finalcogs = '';
                        productPrice = (product.margin != undefined) ? sp.airPrice.price + (sp.airPrice.price * product.margin / 100) : sp.airPrice.price;
                        compare_at_price = parseFloat(sp.airPrice.mrp);
                        cogs = parseFloat(sp.airPrice.cogs);
                        let msrp = getMsrp(compare_at_price);
                        finalcogs = sp.airPrice.price
                        let finalcompareprice = (product.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price;
                        if(product.mId == '611dd6963f897a8f2921d8fa'){
                            finalcogs = fp
                            productPrice = (product.margin != undefined) ? Number(fp) + (fp * product.margin / 100) : fp
                            finalcompareprice = getMsrp(fp)
                        }

                        if(product.channel == 'ds'){
                            finalcogs = sp.dropshipperPrice.price
                            productPrice = (product.margin != undefined) ? Number(sp.dropshipperPrice.price) + (sp.dropshipperPrice.price * product.margin / 100) : sp.dropshipperPrice.price;
                            compare_at_price = parseFloat(sp.dropshipperPrice.mrp);
                            finalcompareprice = (product.mId != '600d67ca51b296e894178f3c') ? getMsrp(compare_at_price) : compare_at_price;
                        }
                        let newVarientObj = {
                            id: product.vd[0].spvid,
                            sku: productArray.code,
                            price: Math.ceil(productPrice),
                            compare_at_price: (productArray.pmrp ) ? productArray.pmrp : finalcompareprice,
                            inventory_quantity: productArray.quantity,
                            cost: (product.mId != '600d67ca51b296e894178f3c') ? finalcogs : cogs,
                            weight: productArray.weight,
                            weight_unit: "g",
                        };
                        variants.push(newVarientObj);
                        newProductObj = {
                            id: product.spId,
                            title: productArray.name,
                            status: productStatus,
                            body_html : productArray.description,
                            variants: variants,
                        }
                    }
                    let merchantCond = { "_id": product.mId }; 
                    let merchantData = await getMerchantData(merchantCond, 1);
                    let merchantSingleData = merchantData[0];
                    let merchantStoreData = merchantSingleData.storeData[0];
                    const shopRequestUrl = 'https://' + merchantStoreData.storeDomain + '/admin/api/2021-01/products/' + product.spId + '.json';
                    const shopRequestHeaders = {
                        'X-Shopify-Access-Token': merchantStoreData.shopifySecretKey,
                        'Content-Type': 'application/json',
                        'X-Shopify-Hmac-Sha256': merchantStoreData.shopifyApiKey,
                        'X-Shopify-Shop-Domain': merchantStoreData.storeDomain,
                        'X-Shopify-API-Version': '2021-01',
                    };
                    let productData = {};
                    productData = {
                        shopRequestUrl: shopRequestUrl,
                        shopRequestHeaders: shopRequestHeaders,
                        productObj: newProductObj,
                        subscribeId: product._id,
                        shopifyId: product.spId,
                        finalImgUrl: finalImgUrl
                    };
                    var requestUrl = process.env.REQUEST_URL + '/web/update-shopify-products';
                    // requestUrl = 'https://sellercentral.shopperr.in/web/update-shopify-products';
                    try {
                        request.post(requestUrl, { json: productData }).then((respo) => {
                            resolve({ 'error': 0, 'message': 'Products Updated.' });
                        });
                    } catch (error) {
                        console.log(error);
                        resolve({ 'error': 1, 'message': error });
                    }
                }));
            })).then((data) => data).catch((err) => err));
        }

    } else {
        console.log('No Product');
    }
};

async function updatePriceOnMerchantStoresCronOld() {
    // var merchant = '600d67ca51b296e894178f3c';
    // var merchant = '60095d4e9e8dd0bc997ad9a1';
    let products = await SubscribeProducts.find({ $and: [{ "su_status": 1 }, { "suv_status": 0 }, { mId: { $ne: mongoose.Types.ObjectId("600d67ca51b296e894178f3c") } }] }).sort({ _id: -1 }).limit(1);
    // let products = await SubscribeProducts.find({ $and: [  {"spId" : 6729648504985} , { mId: { $ne: mongoose.Types.ObjectId("600d67ca51b296e894178f3c") } }]}).sort({_id : -1}).limit(1);
    // console.log(products.length); return false;
    if (products.length > 0) {
        var product = products[0];
        var cond = { "_id": product._id };
        let updateObj = {
            suv_status: 2
        }
        var dataup = await updateSubscribeProducts(cond, updateObj);
        let productArray = await Products.find({ _id: product.pId }).limit(1);
        if (productArray.length > 0) {
            productArray = productArray[0];
            var suppliers = await User.findOne({ _id: mongoose.Types.ObjectId(productArray.supplier_id) }).limit(1);
            let suppllierOrigin = '';
            if (suppliers.length > 0) {
                suppllierOrigin = suppliers.price_algo;
            }
            var fp = '';
            var pw = '';
            var pbcd = '';
            var pigst = '';
            var pswc = '';
            var mrps = '';
            var lenght = '';
            var width = '';
            var height = '';
            fp = (productArray['price'] != undefined) ? productArray['price'] : 0;
            mrps = (productArray.mrp != undefined) ? productArray.mrp : 0;
            pw = (productArray.weight != undefined) ? productArray.weight : 0;
            lenght = (productArray.length != undefined) ? productArray.length : 0;
            width = (productArray.width != undefined) ? productArray.width : 0;
            height = (productArray.height != undefined) ? productArray.height : 0;
            pbcd = (productArray.bcd != undefined) ? productArray.bcd : 10;
            pigst = (productArray.igst != undefined) ? productArray.igst : 18;
            margin = (productArray.productMargin != undefined) ? productArray.productMargin : 40;
            pswc = (productArray['swcOnBcd'] != undefined) ? productArray['swcOnBcd'] : 10;
            var sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);
            // console.log(Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , lenght , width , height , mrps , sp); return false; 
            var variants = [];
            product.vd.forEach(async function (varient) {
                var varientObj = productArray.varientArray.find((item) => {
                    if (varient.ssvid != undefined) {
                        return (item.varient_id.toString().replace(' ', '') == varient.ssvid.toString().replace(' ', ''));
                    }
                });
                if (varientObj) {
                    fp = (varientObj['price'] != '' && varientObj['price'] != 'undefined') ? varientObj['price'] : 0;
                    mrps = (varientObj.mrp != '' && varientObj.mrp != 'undefined') ? varientObj.mrp : 0;
                    let vsp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);
                    let variantPrice = (product.margin != undefined) ? Number(vsp.airPrice.price) + (vsp.airPrice.price * product.margin / 100) : vsp.airPrice.price;
                    let compare_at_price = parseFloat(vsp.airPrice.mrp);
                    let cogs = parseFloat(vsp.airPrice.cogs);
                    let msrp = getMsrp(compare_at_price);
                    let newVarientObj = {
                        id: varient.spvid,
                        price: Math.ceil(variantPrice),
                        sku: varientObj.sku,
                        compare_at_price: (product.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price,
                        cost: (product.mId != '600d67ca51b296e894178f3c') ? vsp.airPrice.price : cogs,
                        inventory_quantity: varientObj.quantity,
                        weight: productArray.weight,
                        weight_unit: "g",
                    };
                    variants.push(newVarientObj);
                }
            });
            var newProductObj = "";
            if (variants.length != 0) {
                newProductObj = {
                    id: product.spId,
                    title: productArray.name,
                    variants: variants,
                }
            } else {
                let productPrice = (product.margin != undefined) ? sp.airPrice.price + (sp.airPrice.price * product.margin / 100) : sp.airPrice.price;
                let compare_at_price = parseFloat(sp.airPrice.mrp);
                let msrp = getMsrp(compare_at_price);
                let cogs = parseFloat(sp.airPrice.cogs);
                let newVarientObj = {
                    id: product.vd[0].spvid,
                    sku: productArray.code,
                    price: Math.ceil(productPrice),
                    compare_at_price: (product.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price,
                    inventory_quantity: productArray.quantity,
                    cost: (product.mId != '600d67ca51b296e894178f3c') ? sp.airPrice.price : cogs,
                    weight: productArray.weight,
                    weight_unit: "g",
                };
                variants.push(newVarientObj);
                newProductObj = {
                    id: product.spId,
                    title: productArray.name,
                    variants: variants,
                }
            }
            let merchantCond = { "_id": product.mId };
            let merchantData = await getMerchantData(merchantCond, 1);
            let merchantSingleData = merchantData[0];
            let merchantStoreData = merchantSingleData.storeData[0];
            const shopRequestUrl = 'https://' + merchantStoreData.storeDomain + '/admin/api/2021-01/products/' + product.spId + '.json';
            const shopRequestHeaders = {
                'X-Shopify-Access-Token': merchantStoreData.shopifySecretKey,
                'Content-Type': 'application/json',
                'X-Shopify-Hmac-Sha256': merchantStoreData.shopifyApiKey,
                'X-Shopify-Shop-Domain': merchantStoreData.storeDomain,
                'X-Shopify-API-Version': '2021-01',
            };
            // console.log(shopRequestUrl , product.spId); return false;
            var productUpdateStatus = await updateShopifyProductApi(shopRequestUrl, shopRequestHeaders, newProductObj, product._id);
            // console.log(productUpdateStatus , product.spId);  
            if (productUpdateStatus.product.id) {
                try {
                    let cond = { "_id": product._id };
                    let obj = {
                        suv_status: 1
                    }
                    const data = await updateSubscribeProducts(cond, obj);
                } catch (error) {
                    console.log(error);
                }
            }
        }

    } else {
        console.log('No Product');
    }
};
 
async function updateJvBarcode() { 
    let products  = await Products.findOne({barcode : '' , sid: mongoose.Types.ObjectId('602fbb6269fea1bd1b71bcbe')},{code:1, varientArray:1});
    if (products) {
        let productIds = products._id  
        let upBcs = products.varientArray.map((upBc) => { 
            upBc.barcode = upBc.sku
            return upBc
        }) 
        let updateVarObj = {
            barcode: products.code,
            varientArray: upBcs, 
            vd: upBcs 
        }
        console.log(updateVarObj , products.code);  
        Products.updateOne({ "_id": productIds }, { $set: updateVarObj }, { upsert: false }).exec().then(data => {
            console.log(data , 'updateVarObj');
        });  
    } else {
        console.log('No Product data');
    }
}

async function updateShopifyVarientCron() { 
    // router.post('/updateShopifyVarient', async (req, res) => {
    // var merchant = '600d67ca51b296e894178f3c';
    // var merchant = '60095d4e9e8dd0bc997ad9a1';
    let products = await SubscribeProducts.find({ $and: [{"su_status" : 1} , {"suv_status" : 0}, { mId: mongoose.Types.ObjectId("600d67ca51b296e894178f3c") } , { is_vup: { $ne: 1 }}]}).sort({_id : -1}).limit(1);
    // let products = await SubscribeProducts.find({ spId :6631935213708 }).sort({_id : -1}).limit(1);
    // let products = await SubscribeProducts.find({ $and: [{ "su_status": 1 }, { "suv_status": 0 }, { mId: mongoose.Types.ObjectId("600d67ca51b296e894178f3c") }] }).sort({ _id: -1 }).limit(10);
    if (products.length > 0) {
        var subscribeProductIds = products.map(function (id) { return id._id });
        var productIds = products.map(function (id) { return id.pId });
        let updateObj = {
            suv_status: 2
        }
        var dataup = await SubscribeProducts.updateMany({ "_id": { $in: subscribeProductIds } }, { $set: updateObj }, { upsert: false });
        let productArrays = await Products.find({ _id: { $in: productIds } });
        if (productArrays.length > 0) {
            const updates = (await Promise.all(productArrays.map((productArray) => {
                return (new Promise(async (resolve, reject) => {
                    var product = '';
                    product = products.find((item) => { return item.pId == productArray._id.toString() }); 
                    if (product == -1) {
                        resolve({ 'error': 1, 'Message': 'Products Not found' });
                        return false;
                    }
                    var productStatus = 'draft'
                    if (productArray.quantity > 0) {
                        productStatus = 'active'
                    }
                    var imgUrls = productArray.imgUrl;
                    var finalImgUrl = imgUrls.map(function (imgUrl) {
                        var imgSrc = {
                            "position": imgUrl.position,
                            "src": process.env.S3_BUCKET_FILE_URL + '/' + imgUrl.src
                        }
                        return imgSrc
                    });
                    let tagData = await gettagsById(productArray.tags); 
                    let suppliers = await User.findOne({ _id: mongoose.Types.ObjectId(productArray.supplier_id) });
                    let suppllierOrigin = '';
                    let supplier_id = 'Shopperr';
                    if (suppliers) {
                        suppllierOrigin = suppliers.price_algo;
                        supplier_id = suppliers.supplier_id;
                    }
                    let fp = (productArray['price'] != undefined) ? productArray['price'] : 0;
                    let mrps = (productArray.mrp != undefined) ? productArray.mrp : 0;
                    let pw = (productArray.weight != undefined) ? productArray.weight : 0;
                    let length = (productArray.length != undefined) ? productArray.length : 0;
                    let width = (productArray.width != undefined) ? productArray.width : 0;
                    let height = (productArray.height != undefined) ? productArray.height : 0;
                    let pbcd = (productArray.bcd != undefined) ? productArray.bcd : 10;
                    let pigst = (productArray.igst != undefined) ? productArray.igst : 18;
                    let margin = (productArray.productMargin != undefined) ? productArray.productMargin : 40;
                    let pswc = (productArray['swcOnBcd'] != undefined) ? productArray['swcOnBcd'] : 10;
                    let sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, length, width, height, mrps, margin);
                    // console.log(Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , length , width , height , mrps , sp);   
                    // var variants = [];
                    let variants = (await Promise.all(product.vd.map((varient) => {
                        return (new Promise(async (resolve, reject) => {
                            var varientObj = productArray.varientArray.find((item) => {
                                if (varient.ssvid != undefined) {
                                    return (item.varient_id.toString().replace(' ', '') == varient.ssvid.toString().replace(' ', ''));
                                }
                            });
                            if (!varientObj) {
                                resolve({ 'error': 1, 'message': 'Product varient not matched.' });
                                return false;
                            }
                            let variantPrice = '';
                            let compare_at_price = '';
                            let cogs = '';
                            fp = (varientObj['price'] != '' && varientObj['price'] != 'undefined') ? varientObj['price'] : 0;
                            mrps = (varientObj.mrp != '' && varientObj.mrp != 'undefined') ? varientObj.mrp : 0;
                            var vsp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, length, width, height, mrps, margin);
                            variantPrice = (product.margin != undefined) ? Number(vsp.airPrice.price) + (vsp.airPrice.price * product.margin / 100) : vsp.airPrice.price;
                            compare_at_price = parseFloat(vsp.airPrice.mrp);
                            cogs = parseFloat(vsp.airPrice.cogs);
                            let finalcompareprice = (product.mId != '600d67ca51b296e894178f3c') ? compare_at_price * 2 : compare_at_price;
                            let newVarientObj = {
                                id: varient.spvid,
                                price: Math.ceil(variantPrice),
                                sku: varientObj.sku,
                                compare_at_price: (productArray.pmrp) ? productArray.pmrp : finalcompareprice,
                                cost: cogs,
                                inventory_quantity: varientObj.quantity,
                                weight: productArray.weight,
                                weight_unit: "g",
                            };
                            resolve(newVarientObj);
                        }));
                    })).then((data) => data).catch((err) => err));
                    variants = variants.filter((variant) => {
                        if (variant.error == 1) {
                            return false;
                        }
                        return true;
                    });
                    // console.log(variants); return false;
                    var newProductObj = "";
                    if (variants.length != 0) {
                        newProductObj = {
                            id: product.spId,
                            title: productArray.name,
                            status: productStatus,
                            tags : tagData.toString(),
                            body_html : productArray.description,
                            vendor : supplier_id,
                            variants: variants,
                        }
                    } else {
                        let productPrice = ''
                        let compare_at_price = '';
                        let cogs = '';
                        productPrice = (product.margin != undefined) ? sp.airPrice.price + (sp.airPrice.price * product.margin / 100) : sp.airPrice.price;
                        compare_at_price = parseFloat(sp.airPrice.mrp);
                        cogs = parseFloat(sp.airPrice.cogs);
                        let finalcompareprice = (product.mId != '600d67ca51b296e894178f3c') ? compare_at_price * 2 : compare_at_price;
                        let newVarientObj = {
                            id: product.vd[0].spvid,
                            sku: productArray.code,
                            price: Math.ceil(productPrice),
                            compare_at_price: (productArray.pmrp) ? productArray.pmrp : finalcompareprice,
                            inventory_quantity: productArray.quantity,
                            cost: cogs,
                            weight: productArray.weight,
                            weight_unit: "g",
                        };
                        variants.push(newVarientObj);
                        newProductObj = {
                            id: product.spId,
                            title: productArray.name,
                            status: productStatus,
                            tags : tagData.toString(),
                            body_html : productArray.description,
                            vendor : supplier_id,
                            variants: variants,
                        }
                    }
                    let merchantCond = { "_id": product.mId };
                    let merchantData = await getMerchantData(merchantCond, 1);
                    let merchantSingleData = merchantData[0];
                    let merchantStoreData = merchantSingleData.storeData[0];
                    const shopRequestUrl = 'https://' + merchantStoreData.storeDomain + '/admin/api/2021-01/products/' + product.spId + '.json';
                    const shopRequestHeaders = {
                        'X-Shopify-Access-Token': merchantStoreData.shopifySecretKey,
                        'Content-Type': 'application/json',
                        'X-Shopify-Hmac-Sha256': merchantStoreData.shopifyApiKey,
                        'X-Shopify-Shop-Domain': merchantStoreData.storeDomain,
                        'X-Shopify-API-Version': '2021-01',
                    };
                    let productData = {};
                    productData = {
                        shopRequestUrl: shopRequestUrl,
                        shopRequestHeaders: shopRequestHeaders,
                        productObj: newProductObj,
                        subscribeId: product._id,
                        shopifyId: product.spId,
                        finalImgUrl: finalImgUrl
                    };
                    // console.log(productData.productObj);  return false;
                    var requestUrl = process.env.REQUEST_URL + '/web/update-shopify-products';
                    // requestUrl = 'https://sellercentral.shopperr.in/web/update-shopify-products';
                    try {
                        request.post(requestUrl, { json: productData }).then((respo) => {
                            resolve({ 'error': 0, 'message': 'Products Updated.' });
                        });
                    } catch (error) {
                        console.log(error);
                        resolve({ 'error': 1, 'message': error });
                    }
                }));
            })).then((data) => data).catch((err) => err));
        }

    } else {
        console.log('No Product');
    }
};
// router.post('/getShopifyUploadedProductVarientsByTitleCron', async (req, res) => { 
async function getShopifyUploadedProductVarientsByTitleCron() {
    // var products = await SubscribeProducts.find({ su_status: 2 , error_status :3}).sort({'_id' : -1}).limit(10);
    var products = await SubscribeProducts.find({ su_status: 2, error_status: { $exists: false } }).sort({ '_id': -1 }).limit(10);
    if (products.length > 0) {
        var subscribeProductIds = products.map(function (id) { return id._id });
        var productIds = products.map(function (id) { return id.pId });
        let updateObj = {
            error_status: 3
        }
        var dataup = await SubscribeProducts.updateMany({ "_id": { $in: subscribeProductIds } }, { $set: updateObj }, { upsert: false });;
        let productArrays = await Products.find({ _id: { $in: productIds } });
        // console.log(dataup , 'subscribeProductIds' , productIds , 'productArrays' , productArrays.length , products.length);
        if (productArrays.length > 0) {
            for (var i = 0; i < productArrays.length; i++) {
                let product = productArrays[i];
                let subscribeProduct = products.find((item) => { return item.pId == product._id.toString() });
                if (subscribeProduct == -1) {
                    console.log('Products Id not matched in subcribedata');
                    return false;
                }
                // console.log(subscribeProduct , 'subscribeProduct' , product._id );
                let merchantCond = { "_id": subscribeProduct.mId };
                let subscribeId = { "_id": subscribeProduct._id };
                let merchantData = await getMerchantData(merchantCond, 1);
                let merchantInfo = merchantData[0].storeData[0];
                if (merchantInfo) {
                    var requestUrl = process.env.REQUEST_URL + '/web/get-shopify-products';
                    // requestUrl = 'https://sellercentral.shopperr.in/web/update-shopify-products';
                    try {
                        var productData = {
                            subscribeId: subscribeProduct._id,
                            product: product,
                            url: "https://" + merchantInfo.shopifyApiKey + ":" + merchantInfo.shopifySecretKey + "@" + merchantInfo.storeDomain + "/admin/api/2021-01/products.json?title=" + product.name.replace("&", "%26")
                        }
                        // console.log(productData , 'productData');
                        request.post(requestUrl, { json: productData }).then((respo) => {});
                    } catch (error) {
                        console.log(error);
                    }
                } else {
                    console.log('No Merchant found');
                }
            }

        }
    }
};

router.post('/get-shopify-products', async function (req, res) {
    var shopRequestUrl = req.body.url;
    var subscribeId = mongoose.Types.ObjectId(req.body.subscribeId);
    var product = req.body.product;
    request.get(shopRequestUrl).then(async (data) => {
        var result = JSON.parse(data);
        if (result.products.length > 0) {
            var data = result.products[0];
            var varientArray = [];
            if (data.variants.length > 0) {
                data.variants.forEach(function (varient) {
                    var varientObj = product.varientArray.find((item) => {
                        return item.varient == varient.title;
                    });
                    var newVarientObj = {};
                    if (varientObj) {
                        newVarientObj = {
                            spvid: varient.id,
                            ssvid: varientObj.varient_id,
                        };
                        varientArray.push(newVarientObj);
                    } else {
                        newVarientObj = {
                            spvid: varient.id,
                        };
                        varientArray.push(newVarientObj);
                    }
                });
            }
            var updateVariant = {};
            if (data.images.length > 0) {
                updateVariant = {
                    vd: varientArray,
                    su_status: 1,
                    suv_status: 0,
                    error_status: 1
                }
            } else {
                updateVariant = {
                    vd: varientArray,
                    su_status: 1,
                    img_status: 1,
                    suv_status: 0,
                    error_status: 1
                }
            }
            try {
                var updata = await SubscribeProducts.updateOne({ "_id": subscribeId }, { $set: updateVariant }, { upsert: false });
            } catch (err) {
                console.log(err);
            }
        } else {
            var updateVariantt = {
                error_status: 2
            }
            try {
                var updata = await SubscribeProducts.updateOne({ "_id": subscribeId }, { $set: updateVariantt }, { upsert: false });
            } catch (err) {
                console.log(err);
            }
        }
    });
});

router.post('/update-shopify-products', async function (req, res) {
    var shopRequestUrl = req.body.shopRequestUrl;
    var shopRequestHeaders = req.body.shopRequestHeaders;
    var newProductObj = req.body.productObj;
    var subscribeId = mongoose.Types.ObjectId(req.body.subscribeId);
    var shopifyId = req.body.shopifyId;
    var finalImgUrl = req.body.finalImgUrl;
    // console.log(newProductObj , shopifyId , subscribeId);
    var productUpdateStatus = await updateShopifyProductApi(shopRequestUrl, shopRequestHeaders, newProductObj, subscribeId);
    if (productUpdateStatus.product.id) {
        try {
            let cond = { "_id": subscribeId };
            let obj = {
                suv_status: 1
            }
            const data = await updateSubscribeProducts(cond, obj);
            res.send(data);
        } catch (error) {
            console.log(error);
        }
        if (productUpdateStatus.product.images.length == 0) {
            if (finalImgUrl.length != 0) {
                newProductImgObj = {
                    id: shopifyId,
                    images: finalImgUrl
                }
                var productUpdateImages = await updateShopifyProductApi(shopRequestUrl, shopRequestHeaders, newProductImgObj, subscribeId);
                if (productUpdateImages.product.id) {
                    try {
                        let cond = { "_id": subscribeId };
                        let obj1 = {
                            img_status: 0
                        }
                        const data1 = await updateSubscribeProducts(cond, obj1);
                    } catch (error) {
                        console.log(error);
                    }
                }
            }
        }
    }
});

function getMerchantData(cond, limit) {
    return new Promise((resolve, reject) => {
        try {
            let productData = MerchantUser.find(cond).sort({ '_id': -1 }).limit(limit);
            resolve(productData);
        } catch (err) {
            reject(err);
        }
    })
}

function updateShopifyProductApi(shopRequestUrl, shopRequestHeaders, productObj, subscribeId = '') {
    return new Promise((resolve, reject) => {
        request.put(shopRequestUrl, { headers: shopRequestHeaders, json: { "product": productObj } }).then(async (shopResponse) => {
            resolve(shopResponse);
        }).catch(async (error) => {
            let cond = { "_id": subscribeId };
            let obj = {
                error_status: 3
            }
            const data = await updateSubscribeProducts(cond, obj);
        });
    });
}

async function updateTagsCronTab() {
    let products = await SubscribeProducts.find({ $and: [{ "mId": { $exists: false } }, { "su_status": 1 }] }).limit(1);
    if (products.length > 0) {
        var product = products['0'];
        let updateObj = {
            tg_status: 2
        }
        const data = await SubscribeProducts.updateOne({ "_id": product._id }, { $set: updateObj }, { upsert: false });
        let productArray = await Products.find({ _id: product.pId }).limit(1);
        if (productArray.length > 0) {
            var productData = productArray['0'];
            let category = await Category.find({ "category_id": productData.cat_id }).limit(1);
            if (category.length > 0) {
                let savedCategory = await UpdatedCategory.find({ "catName": category['0'].title }).limit(1);
                if (!savedCategory.length) {
                    var updatedCategory = new UpdatedCategory({
                        catName: category['0'].title,
                    });
                    try {
                        var savedcat = await updatedCategory.save();
                    } catch (err) {
                        console.log(err);
                    }
                }
                let obj = {};
                obj = {
                    "product": {
                        "id": product.spId,
                        "tags": category['0'].title
                    }
                }
                const shopRequestUrl = 'https://shopperr2.myshopify.com/admin/api/2021-01/products/' + product.spId + '.json';
                const shopRequestHeaders = {
                    'X-Shopify-Access-Token': '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',
                    'Content-Type': 'application/json',
                    'X-Shopify-Hmac-Sha256': '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',
                    'X-Shopify-Shop-Domain': 'shopperr2.myshopify.com',
                    'X-Shopify-API-Version': '2021-01',
                };
                request.put(shopRequestUrl, { headers: shopRequestHeaders, json: obj }).then(async (shopResponse) => {
                    try {
                        let obj = {
                            tg_status: 1
                        }
                        const data = await SubscribeProducts.updateOne({ "_id": product._id }, { $set: obj }, { upsert: false });
                    }
                    catch (error) {
                        console.log(error);
                    }
                }).catch((error) => {
                    console.log(error);
                });
            }
        }
    }
};

router.post('/getMetafieldApi', async (req, res) => {

});
async function updateMetafieldCronTab() {
    let products = await SubscribeProducts.find({ $and: [{ "mf_status": { $exists: false } }, { "su_status": 1 }] }).limit(1);
    if (products.length > 0) {
        let product = products['0'];
        let merchantCond = { "_id": product.mId };
        let merchantData = await getMerchantData(merchantCond, 1);
        if (merchantData.length > 0) {
            let updateObj = {
                mf_status: 2
            }
            const data = await SubscribeProducts.updateOne({ "_id": product._id }, { $set: updateObj }, { upsert: false });
            let productArray = await Products.find({ _id: product.pId }).limit(1);
            var productData = productArray['0'];
            var suppliers = await User.find({ _id: productData.sid }).limit(1);
            let suppllierOrigin = '';
            if (suppliers.length > 0) {
                suppllierOrigin = suppliers[0].origin;
            }
            var shippingWeight = '';
            var factory_price = '';
            var getDuty = '';
            var getFrieghtCost = '';
            var STK_factory_price = '';
            var exhangeCost = '';
            var product_weight = '';
            var gstImpact = '';
            var shippingCharge = '';
            var shipping_cost_per_kg = 80;
            var productSubTotal = '';
            var productTotal = '';
            var product_pieces = 50;
            STK_factory_price = productData.price;
            exhangeCost = (STK_factory_price * 2 / 100)
            STK_factory_price = exhangeCost + STK_factory_price;
            factory_price = (STK_factory_price * 21 / 100) + STK_factory_price;
            gstImpact = productData.sp - (productData.sp * 100 / 118);
            getDuty = STK_factory_price * 56 / 100;
            product_weight = productData.weight / 1000;
            getFrieghtCost = (580 * product_weight * 1.18);
            shippingWeight = product_weight * product_pieces;
            shippingCharge = shippingWeight * shipping_cost_per_kg;
            productSubTotal = productData.sp * product_pieces;
            productTotal = productSubTotal + shippingCharge;
            let obj = {};
            obj = {
                "product": {
                    "id": product.spId,
                    "metafields": [
                        {
                            "key": "frieght_cost",
                            "value": String(getFrieghtCost.toFixed(2)),
                            "value_type": "string",
                            "namespace": "frieght_cost"
                        },
                        {
                            "key": "gst_tax",
                            "value": String(gstImpact.toFixed(2)),
                            "value_type": "string",
                            "namespace": "gst_tax"
                        },
                        {
                            "key": "duty",
                            "value": String(getDuty.toFixed(2)),
                            "value_type": "string",
                            "namespace": "duty"
                        },
                        {
                            "key": "product_pieces",
                            "value": String(product_pieces),
                            "value_type": "string",
                            "namespace": "product_pieces"
                        },
                        {
                            "key": "shipping_charge",
                            "value": String(shippingCharge.toFixed(2)),
                            "value_type": "string",
                            "namespace": "shipping_charge"
                        },
                        {
                            "key": "shipping_time",
                            "value": "6-10",
                            "value_type": "string",
                            "namespace": "shipping_time"
                        },
                        {
                            "key": "dispatch_time",
                            "value": "2",
                            "value_type": "string",
                            "namespace": "dispatch_time"
                        },
                        {
                            "key": "factory_price",
                            "value": String(factory_price.toFixed(2)),
                            "value_type": "string",
                            "namespace": "factory_price"
                        },
                        {
                            "key": "product_sub_total",
                            "value": String(productSubTotal.toFixed(2)),
                            "value_type": "string",
                            "namespace": "product_sub_total"
                        },
                        {
                            "key": "product_total",
                            "value": String(productTotal.toFixed(2)),
                            "value_type": "string",
                            "namespace": "product_total"
                        },
                        {
                            "key": "country_of_origin",
                            "value": (suppllierOrigin == 'china') ? "China" : "India",
                            "value_type": "string",
                            "namespace": "country_of_origin"
                        }
                    ]
                }
            }
            let merchantSingleData = merchantData[0];
            let merchantStoreData = merchantSingleData.storeData[0];
            const shopRequestUrl = 'https://' + merchantStoreData.storeDomain + '/admin/api/2021-01/products/' + product.spId + '.json';
            const shopRequestHeaders = {
                'X-Shopify-Access-Token': merchantStoreData.shopifySecretKey,
                'Content-Type': 'application/json',
                'X-Shopify-Hmac-Sha256': merchantStoreData.shopifyApiKey,
                'X-Shopify-Shop-Domain': merchantStoreData.storeDomain,
                'X-Shopify-API-Version': '2021-01',
            };
            var productUpdateStatus = await updateShopifyProductApi(shopRequestUrl, shopRequestHeaders, obj);
            if (productUpdateStatus.product.id) {
                try {
                    let cond = { "_id": product._id };
                    let obj = {
                        suv_status: 1
                    }
                    const data = await updateSubscribeProducts(cond, obj);
                } catch (error) {
                    console.log(error);
                }
            }
        } else {
            console.log('Store api does not exist.');
        }
    }
};

function getCategoryByLimit(cond, limit) {
    return new Promise((resolve, reject) => {
        try {
            let productData = Category.find(cond).limit(Number(limit));
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}
function getUpdatedCategoryDataByLimit(cond, limit) {
    return new Promise((resolve, reject) => {
        try {
            let productData = UpdatedCategory.find(cond).limit(Number(limit));
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

function saveUpdatedCategoryData(obj) {
    var updatedCategory = new UpdatedCategory();
    try {
        var savedcat = updatedCategory.save();
        resolve(savedcat);
    } catch (err) {
        return true;
    }
}
function uploadShopifyApiCall(obj, merchantStoredata) {
    return new Promise((resolve, reject) => {
        const shopRequestUrl = 'https://' + merchantStoredata.storeDomain + '/admin/api/2021-01/products.json';
        const shopRequestHeaders = {
            'X-Shopify-Access-Token': merchantStoredata.shopifySecretKey,
            'Content-Type': 'application/json',
            'X-Shopify-Hmac-Sha256': merchantStoredata.shopifyApiKey,
            'X-Shopify-Shop-Domain': merchantStoredata.storeDomain,
            'X-Shopify-API-Version': '2021-01',
        };
        request.post(shopRequestUrl, { headers: shopRequestHeaders, json: obj }).then((shopResponse) => {
            resolve(shopResponse);
        }).catch(async (error) => {
            var log = new Logs({
                crName: 'addShopifyProductsCron',
                logs: error,
                date: new Date(),
            });
            await log.save();
            return true;
        });
    });
}
async function addShopifyProducts(products, index) {
    if (products.length < index + 1) {
        return false;
    }
    var ids = products[index];
    let merchantCond = { "_id": ids.mId };
    let merchantdata = await getMerchantData(merchantCond, 1);
    if (merchantdata.length > 0) {
        let updateObj = {
            su_status: 2
        }
        await SubscribeProducts.updateOne({ "_id": ids._id }, { $set: updateObj }, { upsert: false });
        let product = await Products.findOne({ '_id': ids.pId });
        var tagData = [];
        var images = [];
        if (product.pd_location == "China") {
            tagData.push('sfc_products');
            if (product.cat_id != '' && product.cat_id != 'undefined') {
                let getCategoryCond = { "category_id": product.cat_id };
                let category = await getCategoryByLimit(getCategoryCond, 1);
                if (category.length > 0) {
                    let getCategoryCond = { "catName": category['0'].title };
                    let savedCategory = await getUpdatedCategoryDataByLimit(getCategoryCond, 1);
                    if (!savedCategory.length) {
                        let updatedCatObj = { catName: category['0'].title }
                        await saveUpdatedCategoryData(updatedCatObj);
                    }
                    tagData.push(category['0'].title);
                }
            }
        } else {
            tagData = await gettagsById(product.tags);
        }
        if (product.imgUrl.length) {
            product.imgUrl.forEach(function (img) {
                if (img.src != undefined) {
                    images.push({ 'src': process.env.S3_BUCKET_FILE_URL + '/' + img.src });
                }
            });
        }

        let variants = [];
        var suppliers = await User.findOne({ _id: mongoose.Types.ObjectId(product.supplier_id) });
        let suppllierOrigin = '';
        let supplier_id = 'Shopperr'; 
        if (suppliers) {
            suppllierOrigin = suppliers.price_algo;
            supplier_id = suppliers.supplier_id;
        }
        var fp = '';
        var pw = '';
        var pbcd = '';
        var pigst = '';
        var pswc = '';
        var mrps = '';
        var lenght = '';
        var width = '';
        var height = '';
        fp = (product.price != undefined) ? product.price : 0;
        mrps = (product.mrp != undefined) ? product.mrp : 0;
        pw = (product.weight != undefined) ? product.weight : 0;
        lenght = (product.length != undefined) ? product.length : 0;
        width = (product.width != undefined) ? product.width : 0;
        height = (product.height != undefined) ? product.height : 0;
        pbcd = (product.bcd != undefined) ? product.bcd : 10;
        pigst = (product.igst != undefined) ? product.igst : 18;
        margin = (product.productMargin != undefined) ? product.productMargin : 40;
        pswc = (product.swcOnBcd != undefined) ? product.swcOnBcd : 10;
        var sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);
        // console.log(sp, Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);
        if (product.varientArray.length > 0) {  
            variants = (await Promise.all(product.varientArray.map((variant) => {
                return (new Promise(async (resolve, reject) => {
                    var variantPrice = '';
                    fp = (variant.price != '' && variant.price != 'undefined') ? variant.price : 0;
                    var vsp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);
                    // console.log(vsp , Number(fp) , Number(pw) , suppllierOrigin , pbcd , pigst , pswc , lenght , width , height , mrps , margin);
                    variantPrice = parseFloat(vsp.airPrice.price);
                    compare_at_price = parseFloat(vsp.airPrice.mrp);
                    cogs = parseFloat(vsp.airPrice.cogs);
                    var string = variant.varient;
                    var array = string.split("/");
                    var [option1, option2, option3] = array;
                    msrp = getMsrp(compare_at_price);
                    var vfinalPrice = '';
                    vfinalPrice = (ids.margin != undefined) ? Number(variantPrice) + (variantPrice * ids.margin / 100) : variantPrice;
                    if(ids.mId == '611dd6963f897a8f2921d8fa'){
                        vfinalPrice = (ids.margin != undefined) ? Number(fp) + (fp * ids.margin / 100) : fp
                        variantPrice = fp
                        msrp = getMsrp(fp)
                    }

                    if(ids.channel == 'ds'){
                        vfinalPrice = (ids.margin != undefined) ? Number(vsp.dropshipperPrice.price) + (vsp.dropshipperPrice.price * ids.margin / 100) : vsp.dropshipperPrice.price;
                        variantPrice = parseFloat(vsp.dropshipperPrice.price);
                        compare_at_price = parseFloat(vsp.dropshipperPrice.mrp);
                        msrp = getMsrp(compare_at_price);
                    }

                    var finalvariant1 = {
                        "option1": (option1 != undefined) ? option1 : '',
                        "option2": (option2 != undefined) ? option2 : '',
                        "option3": (option3 != undefined) ? option3 : '',
                        "taxable": false,
                        "sku": variant.sku,
                        "price": Math.ceil(vfinalPrice),
                        "cost": (ids.mId != '600d67ca51b296e894178f3c') ? variantPrice : cogs,
                        "compare_at_price": (ids.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price,
                        "inventory_quantity": variant.quantity,
                        "weight": product.weight,
                        "weight_unit": "g",
                        "requires_shipping": true,
                        "fulfillment_service": "manual",
                        "inventory_management": "shopify"
                    }
                    resolve(finalvariant1);
                }));
            })).then((data) => data).catch((err) => err));
        } else {
            variantPrice = parseFloat(sp.airPrice.price);
            compare_at_price = parseFloat(sp.airPrice.mrp);
            cogs = parseFloat(sp.airPrice.cogs);
            msrp = getMsrp(compare_at_price);
            var finalPrice = (ids.margin != undefined) ? Number(variantPrice) + (variantPrice * ids.margin / 100) : variantPrice;
           
            if(ids.mId == '611dd6963f897a8f2921d8fa'){
                finalPrice = (ids.margin != undefined) ? Number(fp) + (fp * ids.margin / 100) : fp
                variantPrice = fp
                msrp = getMsrp(fp) 
            }

            if(ids.channel == 'ds'){
                finalPrice = (ids.margin != undefined) ? Number(sp.dropshipperPrice.price) + (sp.dropshipperPrice.price * ids.margin / 100) : sp.dropshipperPrice.price;
                variantPrice = parseFloat(sp.dropshipperPrice.price);
                compare_at_price = parseFloat(sp.dropshipperPrice.mrp);
                msrp = getMsrp(compare_at_price);
            }

            var finalvariant = {
                "taxable": false,
                "sku": product.code,
                "price": Math.ceil(finalPrice),
                "cost": (ids.mId != '600d67ca51b296e894178f3c') ? variantPrice : cogs,
                "compare_at_price": (ids.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price,
                "inventory_quantity": product.quantity,
                "weight": product.weight,
                "weight_unit": "g",
                "requires_shipping": true,
                "fulfillment_service": "manual",
                "inventory_management": "shopify"
            }
            variants.push(finalvariant);
        }
        let obj = {};
        obj = {
            product: {
                "title": product.name,
                "body_html": product.description,
                "vendor": supplier_id,
                "images": images,
                "sku": product.code,
                "tags": tagData,
                "variants": variants,
                "options": product.options
            },
        }
        // console.log(obj.product);  return false;
        if (images.length > 0) {
            let merchantSingledata = merchantdata[0];
            let merchantStoredata = merchantSingledata.storeData[0];
            let shopifyData = await uploadShopifyApiCall(obj, merchantStoredata);
            if (shopifyData.product) {
                // console.log(shopifyData.product);
                let varientArray = [];
                shopifyData.product.variants.forEach(function (varient) {
                    var varientObj = product.varientArray.find((item) => {
                        return item.varient == varient.title;
                    });
                    var newVarientObj = {};
                    if (varientObj) {
                        newVarientObj = {
                            spvid: varient.id,
                            ssvid: varientObj.varient_id,
                        };
                        varientArray.push(newVarientObj);
                    } else {
                        newVarientObj = {
                            spvid: varient.id
                        };
                        varientArray.push(newVarientObj);
                    }
                });
                let variantObj = {
                    spId: shopifyData.product.id,
                    su_status: 1,
                    vd: varientArray
                }
                // console.log(variantObj, 'variantObj');
                let updateSubscribeProductCondition = { "_id": ids._id };
                const data = await updateSubscribeProducts(updateSubscribeProductCondition, variantObj);
            }
        } else {
            console.log('Duplicate Products');
        }
        return false;
    } else {
        console.log('Merchant detail not found.' + product.mId);
    }
}

function updateSubscribeProducts(cond, data) {
    return new Promise((resolve, reject) => {
        try {
            let productData = SubscribeProducts.update(cond, { $set: data }, { multi: true });
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

async function addShopifyProductCronTab() {
    var limit = 1;
    // var merchant = mongoose.Types.ObjectId("600d67ca51b296e894178f3c"); 
    // var merchant = mongoose.Types.ObjectId("60095d4e9e8dd0bc997ad9a1"); 
    let products = await SubscribeProducts.find({ "su_status": 0 }).sort({ '_id': -1 }).limit(parseInt(limit));
    // let products = await SubscribeProducts.find({"_id" : mongoose.Types.ObjectId("611e01b518e7cb220feda13f")}).limit(parseInt(limit)); 
    if (products.length > 0) {
        addShopifyProducts(products, 0);
    } else {
        console.log('No subscribe Products');
    }
}
//Add product to shopify
router.post('/addToShopify', async (req, res) => {
    var limit = req.body.limit;
    var merchant = mongoose.Types.ObjectId('60095d4e9e8dd0bc997ad9a1');
    let products = await SubscribeProducts.find({ $and: [{ "mId": merchant }, { "su_status": 0 }] }, { pId: 1 }).limit(parseInt(limit));
    // let products = await SubscribeProducts.find({ $and: [{"mId": merchant} , {"pId" : mongoose.Types.ObjectId('602f909e15af4039e0fac0aa')} , {"su_status" : 1}]},{ pId: 1 }).limit(parseInt(limit));

    if (products.length > 0) {
        addShopifyProducts(products, 0);
    }
});


var shopifyDynmicUrl = 'https://1d71afb6d12f0167126eaa2f001d767e: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@quanyou1.myshopify.com/admin/api/2021-01/products.json?';
function createDynamicURL(params) {
    shopifyDynmicUrl = 'https://1d71afb6d12f0167126eaa2f001d767e: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@quanyou1.myshopify.com/admin/api/2021-01/products.json?' + params;
    return shopifyDynmicUrl;
}
router.post('/shopifyProduct', async (req, res) => {
    var collection_id = req.body.collection_id;
    var limit = req.body.limit;
    bulkProductUploader(createDynamicURL('collection_id=' + collection_id + '&limit=' + limit), 1, limit, req.body);
});

function bulkProductUploader(url, count, limit, bodyParam) {
    request
        .get(url, function (req, respose) {
            let pagination = false;
            let link = '';
            if (respose.headers.link) {
                shopifyDynmicUrl = false;
                patt = new RegExp("(?=page_info=).*(?=>;)", "g");
                pagination = respose.headers.link.split(", ");
                link = pagination.pop();
                link = link.replace("&page_info", "%26page_info");
                let params = patt.exec(link);
                params += '&link=' + link;
                params += '&limit=' + limit;
                createDynamicURL(params);
            }
            if (!pagination || link.search('rel="next"') == -1) {
                shopifyDynmicUrl = false;
            }
        }).then((data) => {
            var response = JSON.parse(data);
            let shippingObj = {
                method: 'freeShipping',
            };
            var products = response.products;
            products.forEach(async function (product) {
                var productImage = product.images;
                var productVariant = product.variants;
                var price = product.variants[0].price;
                var quentity = product.variants[0].inventory_quantity;
                var sku = product.variants[0].sku;
                var weight = product.variants[0].weight;
                var vmrp = product.variants[0].compare_at_price;
                var sp = await pricealgo(price, weight);
                // console.log(sp); 
                if (!vmrp) {
                    vmrp = sp.mrp;
                }
                var handle = '';
                var productImage = product.images;
                let varientarrays = [];
                let tagarrays = [];
                let mainImage = [];
                var poptionArr = [];
                await generate_handle(product.title, function (result) {
                    handle = result;
                });
                // For product image upload

                if (productImage && productImage.length > 0) {
                    productImage.forEach(function (pimage) {
                        var imgData = { 'url': pimage.src, 'handle': handle };
                        var imgpath = '';
                        var varient_id = '';
                        upload_image(imgData, function (result) {
                            imgpath = result;
                        });
                        var imgres1 = { 'position': pimage.position, 'src': imgpath, 'varient_id': varient_id }
                        mainImage.push(imgres1);
                    });
                }
                //For varient
                if (productVariant.length != 1) {
                    var varientsArr = await varientsArray(productVariant, productImage, handle);
                    varientsArr.forEach(function (vrdata) {
                        mainImage.push(vrdata.Imagedata);
                        varientarrays.push(vrdata.varient);
                    });
                    var productoption = product.options;
                    productoption.forEach(function (popt) {
                        var options = {
                            "name": popt.name,
                            "values": popt.values
                        };
                        poptionArr.push(options);
                    });
                }
                if (tagarrays != '') {
                    tagarrays = tagarrays.toString() + ' , ' + product.tags
                } else {
                    tagarrays = product.tags
                }
                var productsd = new Products({
                    supplier_id: bodyParam.supplier_id,
                    spId: product.id,
                    sid: mongoose.Types.ObjectId(bodyParam.supplier_id),
                    name: product.title,
                    handle: handle,
                    tags: await getTagId(tagarrays),
                    price: Number(price),
                    mrp: Number(vmrp),
                    sp: Number(sp.price),
                    cogs: Number(sp.cogs),
                    quantity: quentity,
                    description: product.body_html,
                    category: product.product_type,
                    code: sku,
                    hsn: '',
                    weight: weight,
                    imgUrl: mainImage,
                    uploaded_on: Date(),
                    options: poptionArr,
                    varients: '',
                    vo: poptionArr,
                    vd: varientarrays,
                    shippingCharge: shippingObj,
                    varientArray: varientarrays,
                    selliingPrice: price,
                    tgs: tagarrays.toString()
                });
                var pduplicate = await Products.find({ 'code': sku }).exec();
                try {
                    if (pduplicate && pduplicate.length > 0) {
                        console.log('Duplicate Product');
                    } else {
                        var newProduct = await productsd.save();
                        console.log('Product Added Successfully.');
                    }
                } catch (error) {
                    console.log(error);
                }
            });
            if (!shopifyDynmicUrl) {
                return false;

            }
            bulkProductUploader(shopifyDynmicUrl, ++count, limit, bodyParam);
        })
        .catch((error) => {
            console.log('order details eroor is', error);
        });
}
router.post('/updateSkuLoop', async (req, res) => {

});
router.get('/getExportExcelDataBySupplier/:id', async (req, res) => {
    let supplierId = mongoose.Types.ObjectId(req.params.id);
    let excelDataObj = await new Promise(async (resolve, reject) => { 
        let data = await CsvUpload.find({ 'spId': supplierId , type : {$in: [1 , 2]}}).sort({ '_id': -1 }).limit(50);
        let count = await CsvUpload.count({ 'spId': supplierId , type : {$in: [1 , 2]} });
        return resolve({ 'data': data, 'count': count });
    })
    let supplierProduct = await Products.countDocuments({'supplier_id' : supplierId});
    let excelData = excelDataObj.data;
    let excelCount = excelDataObj.count;
    let finalData = [];
    excelData.forEach((item, index) => { 
        let singleData = {
            'supplierId': item.spId,
            'status': (item.status == 1) ? "Success" : "Pending",
            'action': (item.type == 1) ? "Import" : "Export",
            'url': (item.url != '') ? item.url : '#',
            'date': moment(item.date).tz("Asia/Kolkata").format("DD/MM/YYYY HH:mm:ss")
        }
        finalData.push(singleData);
    });
    let finalObject = { 'count': excelCount, 'data': finalData , 'product' : supplierProduct}
    res.send(finalObject);
    // console.log(finalObject); 
});

router.get('/getSubscribeExcelDataByMerchant/:id', async (req, res) => {
    let excelDataObj = await new Promise(async (resolve, reject) => {
        let supplierId = mongoose.Types.ObjectId(req.params.id);
        let data = await CsvUpload.find({ 'mId': supplierId , type : {$in: [3 , 4]} }).sort({ '_id': -1 });
        let count = await CsvUpload.count({ 'mId': supplierId , type : {$in: [3 , 4]} });
        return resolve({ 'data': data, 'count': count });
    })
    let excelData = excelDataObj.data;
    let excelCount = excelDataObj.count;
    let finalData = [];
    excelData.forEach((item, index) => { 
        let singleData = {
            'supplierId': item.mId,
            'status': (item.status == 1) ? "Success" : "Pending",
            'url': (item.url != '') ? item.url : '#',
            'date': moment(item.date).tz("Asia/Kolkata").format("DD/MM/YYYY HH:mm:ss")
        }
        finalData.push(singleData);
    });
    let finalObject = { 'count': excelCount, 'data': finalData }
    res.send(finalObject);
    // console.log(finalObject); 
});



function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}


router.post('/uploadSubscribeProductCsv', async (req, res) => {
    var fileContent = req.files.file.data;
    var d = new Date();
    var merchantId = req.body.merchant_id;
    const s3dir = "merchantSubscribeList/" + d.getFullYear().toString() + "/" + (d.getMonth() + 1).toString() + "/";
    var filename = 'upload_' + makeid(6) + '_' + merchantId + '.csv';
    var fullPath = s3dir + filename;
    await uploadExcel(fileContent, s3dir + filename).then(async () => {
        var url = process.env.S3_BUCKET_FILE_URL;
        const csvUpload = await new CsvUpload({
            type: 3,
            cond: [{ 'mId': mongoose.Types.ObjectId(merchantId) }],
            mId: mongoose.Types.ObjectId(merchantId),
            url: url + '/' + fullPath,
            date: new Date()
        });
        try {
            const saveProduct = await csvUpload.save();
            res.send('success');
        } catch (err) {
            res.send("something went wrong");
            console.log(err);
        }
    });
    console.log(merchantId, fileContent);
});
router.post('/uploadProductCsv', async (req, res) => {
    var fileContent = req.files.file.data;
    var d = new Date();
    var supplierId = req.body.supplier_id;
    const s3dir = "import_export/" + d.getFullYear().toString() + "/" + (d.getMonth() + 1).toString() + "/";
    var filename = 'upload' + makeid(6) + '_' + supplierId + '.csv';
    var fullPath = s3dir + filename;
    await uploadExcel(fileContent, s3dir + filename).then(async () => {
        var url = process.env.S3_BUCKET_FILE_URL;
        const csvUpload = await new CsvUpload({
            type: 1,
            cond: [{ 'supplier_id': supplierId }],
            spId: mongoose.Types.ObjectId(supplierId),
            url: url + '/' + fullPath,
            date: new Date()
        });
        // console.log(csvUpload , supplierId);  return false;
        try {
            const saveProduct = await csvUpload.save();
            res.send('success');
        } catch (err) {
            res.send("something went wrong");
            console.log(err);
        }
    });
});

function getProductData(cond) {
    return new Promise((resolve, reject) => {
        try {
            let productData = Products.find({ '_id': cond });
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

function getProductDataByLimit(cond, limit) {
    return new Promise((resolve, reject) => {
        try {
            let productData = Products.find({ '_id': cond }).limit(Number(limit));
            resolve(productData);
        } catch (err) {
            return true;
        }
    })
}

// router.post('/addMerchantSubscribedProduct', async (req, res) => { 
async function addMerchantSubscribedProductCron() {
    var limit = 1;
    var csvRequest = await CsvUpload.findOne({ "status": 0 , "type": 3 });
    // var csvRequest = await CsvUpload.findOne({'_id' : mongoose.Types.ObjectId("60bef1ffa0388854099fab38") }).sort({ '_id': -1 });
    if (csvRequest) {
        var obj = {
            status: 1
        }
        try {
            const data = await CsvUpload.updateOne({ "_id": csvRequest._id }, { $set: obj }, { upsert: false });
        } catch (err) {
            console.log(err);
        }
        var options = {
            uri: csvRequest.url,
            encoding: null
        };
        var merchantId = csvRequest.mId;
        let merCond = { '_id': merchantId }
        let merchantData = await getmerchantData(merCond);
        let shopifyKey = (merchantData.storeData.length != 0 ) ? merchantData.storeData[0].shopifyApiKey ? 1 : 0 : 0
        //let amazonKey = (merchantData.amazonStoreData.length != 0 ) ? merchantData.amazonStoreData[0].MWSAuthToken ? 1 : 0 : 0
        request(options, async function (error, response, body) {
            if (error || response.statusCode !== 200) {
                console.log("failed to get file");
                console.log(error);
                return false;
            } else {
                let csvData = await csv().fromString(body.toString());
                csvData = JSON.stringify(csvData);
                csvData = JSON.parse(csvData); 
                let upStatus = await merchantSubscribeList(csvData, merchantId , shopifyKey);
                return true;
            }
        });
    } else {
        console.log('Merchant not subscribe any products');
        return true;
    }
};

function merchantSubscribeList(skus, merchantId , shopifyKey) {
    return new Promise(function (resolve, reject) {
        if (skus) {
            var skuArray = skus;
            var itemsProcessed = [];
            skuArray.forEach(async (item, i) => {
              await addMerchantSubscribedProduct(item, merchantId , shopifyKey);
            });
            resolve(itemsProcessed);
        }
    })
}

function addMerchantSubscribedProduct(sku, merchantId , shopifyKey) {
    return new Promise(async function (resolve, reject) {
        var isProduct = await getProductDataBySku(sku.Sku);
        if (isProduct.length) {
            var product = isProduct[0];
            let getProductCond = {
                pId: product._id,  
                mId: merchantId
            };
            var subProduct = await getSubscribeProductData(getProductCond, 1);
            var shopperrSubProduct = await getShopperSubscribeProductData(getProductCond, 1);
            if (subProduct.length == 0 && shopifyKey == 1) { 
                var subscribeProducts = await new SubscribeProducts({
                    mId: merchantId,
                    pId: product._id,
                    margin: sku.Margin,
                    dos: new Date(),
                    dom: new Date()
                }); 
                await subscribeProducts.save().then(async (saveStatus) => { 
                    if(!shopperrSubProduct){
                        const shopperrSubscribeProducts = await new ShopperrSubscribeProducts({
                            mId: merchantId,
                            pId: product._id,
                            dos: new Date(),
                            dom: new Date(),
                            sku: product.code,
                            margin: sku.Margin,
                            [mongooseConstantValues.SUBSCRIBE_AS_DRAFT]: 0 
                        });
                        await shopperrSubscribeProducts.save().then((shopperrSubscribe) => {
                            console.log(shopperrSubscribe , 'shopperrSubscribeProducts'); 
                            resolve(shopperrSubscribe);
                        }); 
                    }
                    resolve(saveStatus);
                });
            } else {  
                if(!shopperrSubProduct){
                    const shopperrSubscribeProducts = await new ShopperrSubscribeProducts({
                        mId: merchantId,
                        pId: product._id,
                        dos: new Date(),
                        dom: new Date(),
                        sku: product.code,
                        margin: sku.Margin,
                        [mongooseConstantValues.SUBSCRIBE_AS_DRAFT]: 0 
                    });
                    await shopperrSubscribeProducts.save()
                }
                let upObj = {
                    suv_status: 0,
                    margin: sku.Margin
                }
                let updateSubscribeProductCondition = { pId: product._id, mId: merchantId }; 
                const data = await updateSubscribeProducts(updateSubscribeProductCondition, upObj);
                resolve("Update Subscribe Products.");
            }
        } else {
            resolve('Merchant Product Not found.');
        }
    })
}

router.post('/subcribedata', async (req, res) => {
    var limit = 1;
    var supplierId = mongoose.Types.ObjectId('602fbb6269fea1bd1b71bcbe');
    var products = await Products.find({ "supplier_id": "602fbb6269fea1bd1b71bcbe" });
    let merchant = mongoose.Types.ObjectId(req.body.id);
    if (products.length > 0) {
        products.forEach(async (item) => {
            // console.log('Product Id : ' + item.id );
            var subProduct = await SubscribeProducts.find({ pId: mongoose.Types.ObjectId(item._id), mId: merchant }).limit(1);
            console.log('fdgshgdfhsg', item._id);
            if (subProduct.length > 0) {
                console.log('Merchant Id : ' + merchant + ' , Shopify Id : ' + subProduct[0].spId + ' ,   Product Id : ' + subProduct[0].pId + ' ,suv_status :  ' + subProduct[0].suv_status + ' , su_status :  ' + subProduct[0].su_status + ' , Vd :  ' + subProduct[0].vd);
            }
        });

    } else {
        console.log('No data');
    }
});

async function uploadProductCsvCronTab() {
    var csvRequest = await CsvUpload.findOne({ "status": 0 , "type": 1 }); 
    if (csvRequest) {
        var obj = {
            status: 1
        }
        try {
            await CsvUpload.updateOne({ "_id": csvRequest._id }, { $set: obj }, { upsert: false });
        } catch (err) {
            console.log(err);
            await CsvUpload.updateOne({ "_id": csvRequest._id }, { $set: {status:3} }, { upsert: false })
        }
        var options = {
            uri: csvRequest.url,
            encoding: null
        };
        request(options, async function (error, response, body) {
            if (error || response.statusCode !== 200) {
                console.log("failed to get file");
                console.log(error);
                await CsvUpload.updateOne({ "_id": csvRequest._id }, { $set: {status:3} }, { upsert: false })
            } else {
                let csv_data = await csv().fromString(body.toString());
                csv_data = JSON.stringify(csv_data);
                csv_data = JSON.parse(csv_data);
                var suppliers = await User.find({ _id: mongoose.Types.ObjectId(csvRequest.spId) }).limit(1);
                let suppllierOrigin = '';
                if (suppliers.length > 0) {
                    suppllierOrigin = suppliers[0].price_algo;
                }
                let variantDataList = {};
                csv_data.forEach((item) => {
                    variantDataList[item.id] = variantDataList[item.id] ? variantDataList[item.id] : {};
                    if (item.is_variant == 0) {
                        variantDataList[item.id] = item;
                    } else {
                        if (variantDataList[item.id] && variantDataList[item.id].id == item.id) {
                            variantDataList[item.id].variantData = variantDataList[item.id].variantData ? variantDataList[item.id].variantData : [];
                            variantDataList[item.id].variantData.push(item);
                        }
                    }
                });
                Object.values(variantDataList).forEach(async (product) => {
                    let productId = mongoose.Types.ObjectId(product.id);
                    try {
                        let productData = await getProductData(productId);
                        var updatedVariantArray = [];
                        if (productData.length > 0) {
                            var fp = '';
                            var deliveryPeriod = '';
                            var pw = '';
                            var pbcd = '';
                            var pigst = '';
                            var pswc = '';
                            var mrps = '';
                            var lenght = '';
                            var width = '';
                            var height = '';
                            var margin = '';
                            fp = (product['Ex Factory Price'] != '' && product['Ex Factory Price'] != 'undefined') ? product['Ex Factory Price'] : 0;
                            deliveryPeriod = (product['Delivery period'] != '' && product['Delivery period'] != 'undefined') ? product['Delivery period'] : 0;
                            pw = (product.Weight != '' && product.Weight != 'undefined') ? product.Weight : 0;
                            mrps = (product.MRP != '' && product.MRP != 'undefined') ? product.MRP : 0;
                            lenght = (product.Length != '' && product.Length != 'undefined') ? product.Length : 0;
                            width = (product.Width != '' && product.Width != 'undefined') ? product.Width : 0;
                            height = (product.Height != '' && product.Height != 'undefined') ? product.Height : 0;
                            margin = (product.Margin != '' && product.Margin != 'undefined') ? product.Margin : 40;
                            pbcd = (product.BCD.replace(/\%/g, "") != '' && product.BCD.replace(/\%/g, "") != 'undefined') ? product.BCD.replace(/\%/g, "") : 10;
                            pigst = (product.IGST.replace(/\%/g, "") != '' && product.IGST.replace(/\%/g, "") != 'undefined') ? product.IGST.replace(/\%/g, "") : 18;
                            pswc = (product['SWC on BCD'].replace(/\%/g, "") != '' && product['SWC on BCD'].replace(/\%/g, "") != 'undefined') ? product['SWC on BCD'].replace(/\%/g, "") : 10;
                            var sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);
                            let variantArray = productData[0].varientArray;
                            if (variantArray.length > 0) {
                                var updatedVariantArray = await createVarDataFunction(variantArray, product, suppllierOrigin);
                                var updateVarObj = {
                                    name: product.title,
                                    price: updatedVariantArray[0].price,
                                    sp: updatedVariantArray[0].sp,
                                    mrp: updatedVariantArray[0].mrp,
                                    seaPrice: updatedVariantArray[0].seaPrice,
                                    cogs: sp.airPrice.cogs,
                                    quantity: updatedVariantArray[0].quantity,
                                    length: product.Length,
                                    width: product.Width,
                                    height: product.Height,
                                    weight: pw,
                                    hsn: product.Hsn,
                                    bcd: pbcd,
                                    igst: pigst,
                                    swcOnBcd: pswc,
                                    subtitle: product.Subtitle,
                                    invoicedesc: product.Invoicedesc,
                                    varientArray: updatedVariantArray,
                                    vd: updatedVariantArray,
                                    price_update_flag: 1,
                                    productMargin: margin,
                                    pmrp: product['Product Mrp']
                                };
                                await updateProductData(productId, updateVarObj);
                            } else {
                                var updateVarObj = {
                                    name: product.title,
                                    price: fp,
                                    seaPrice: sp.seaPrice,
                                    sp: sp.airPrice.price,
                                    mrp: sp.airPrice.mrp,
                                    cogs: sp.airPrice.cogs,
                                    quantity: product.Quantity,
                                    length: product.Length,
                                    width: product.Width,
                                    height: product.Height,
                                    weight: product.Weight,
                                    hsn: product.Hsn,
                                    bcd: pbcd,
                                    igst: pigst,
                                    swcOnBcd: pswc,
                                    subtitle: product.Subtitle,
                                    invoicedesc: product.Invoicedesc,
                                    price_update_flag: 1,
                                    productMargin: margin,
                                    pmrp: product['Product Mrp']
                                };
                                await updateProductData(productId, updateVarObj);
                            }
                        }
                    } catch (e) {
                        console.log(e);
                        await CsvUpload.updateOne({ "_id": csvRequest._id }, { $set: {status:3} }, { upsert: false })
                    }
                });
            }
        });
    } else {
        console.log('No data');
    }
};

// async function updateSuvStatusCron(){
router.post('/updateShopifyProductStatus', async (req, res) => {
    let productCond = { "supplier_id": "601aeaf4d84fcb0fc9df3e41" };
    let limit = 1500;
    let products = await getProductByCondition(productCond, limit);
    // console.log(products.length);  return false; 
    if (products.length > 0) {
        let shopifyUpdateStatus = await updateSubscribeProductsData(products);
    } else {
        console.log("No data found");
    }
});

function updateSubscribeProductsData(product) {
    return new Promise((resolve, reject) => {
        let responce = [];
        product.forEach(async (item) => {
            let obj = {
                su_status: 0
            }
            let condition = { "pId": item._id };
            let updateStatus = await updateSubscribeProducts(condition, obj);
        });
        resolve('Data');
    });
}

async function updateSuvStatusCron() {
    let productCond = { "price_update_flag": 1 };
    let limit = 50;
    let products = await getProductByCondition(productCond, limit);
    if (products.length > 0) {
        let shopifyUpdateStatus = await updateShopifyFlag(products);
    } else {
        console.log("No Price update");
    }
};

function updateShopifyFlag(product) {
    return new Promise((resolve, reject) => {
        let responce = [];
        product.forEach(async (item) => {
            let obj = {
                suv_status: 0
            }
            let condition = { "pId": item._id, 'su_status': 1 };
            let updateStatus = await updateSubscribeProducts(condition, obj);
            let productObj = {
                price_update_flag: 0
            }
            let updateProduts = await updateProductData(item._id, productObj);
        });
        resolve('Data');
    });
}

function getProductByCondition(cond, limit) {
    return new Promise((resolve, reject) => {
        var updateResult = Products.find(cond).limit(Number(limit));
        resolve(updateResult);
    })
}

function updateProductData(pId, data) {
    return new Promise((resolve, reject) => {
        var updateResult = Products.updateOne({ "_id": pId }, { $set: data });
        resolve(updateResult);
    })
}
function createVarDataFunction(variantArray, product, suppllierOrigin) {
    return new Promise((resolve, reject) => {
        var updatedVariantArray = [];
        variantArray.forEach(async (variant) => {
            let variantObj = product.variantData.find(ele => ele.Sku == variant.sku);
            if (variantObj) {
                var vfp = '';
                var deliveryPeriod = '';
                var vpw = '';
                var vpbcd = '';
                var vpigst = '';
                var vpswc = '';
                var varSp = '';
                var vmrps = '';
                var lenght = '';
                var width = '';
                var height = '';
                var margin = '';
                vfp = (variantObj['Ex Factory Price'] != '' && variantObj['Ex Factory Price'] != 'undefined') ? variantObj['Ex Factory Price'] : 0;
                deliveryPeriod = (variantObj['Delivery period'] != '' && variantObj['Delivery period'] != 'undefined') ? variantObj['Delivery period'] : 0;
                vpw = (variantObj.Weight != '' && variantObj.Weight != 'undefined') ? variantObj.Weight : 0;
                vmrps = (variantObj.MRP != '' && variantObj.MRP != 'undefined') ? variantObj.MRP : 0;
                lenght = (variantObj.Length != '' && variantObj.Length != 'undefined') ? variantObj.Length : 0;
                width = (variantObj.Width != '' && variantObj.Width != 'undefined') ? variantObj.Width : 0;
                margin = (variantObj.Margin != '' && variantObj.Margin != 'undefined') ? variantObj.Margin : 40;
                height = (variantObj.Height != '' && variantObj.Height != 'undefined') ? variantObj.Height : 0;
                vpbcd = (variantObj.BCD.replace(/\%/g, "") != '' && variantObj.BCD.replace(/\%/g, "") != 'undefined') ? variantObj.BCD.replace(/\%/g, "") : 10;
                vpigst = (variantObj.IGST.replace(/\%/g, "") != '' && variantObj.IGST.replace(/\%/g, "") != 'undefined') ? variantObj.IGST.replace(/\%/g, "") : 18;
                vpswc = (variantObj['SWC on BCD'].replace(/\%/g, "") != '' && variantObj['SWC on BCD'].replace(/\%/g, "") != 'undefined') ? variantObj['SWC on BCD'].replace(/\%/g, "") : 10;
                varSp = await updateShopperrPriceAlgo(Number(vfp), Number(vpw), suppllierOrigin, vpbcd, vpigst, vpswc, lenght, width, height, vmrps, margin);
                // console.log(varSp  );  return false;
                variant.price = vfp;
                variant.mrp = varSp.airPrice.mrp;
                variant.sp = varSp.airPrice.price;
                variant.cogs = varSp.airPrice.cogs;
                variant.quantity = variantObj.Quantity;
                variant.seaPrice = varSp.seaPrice;

            }
            updatedVariantArray.push(variant);
        });
        resolve(updatedVariantArray);
    });
}

router.post('/downloadProductCsv/:supplier_id', async (req, res) => {
    var supplierId = req.params.supplier_id; 
    const csvUpload = await new CsvUpload({
        type: 2,
        cond: [{ 'supplier_id': supplierId }],
        spId: mongoose.Types.ObjectId(supplierId),
        page: req.body.page,
        limit: req.body.limit,
        date: new Date()
    }); 
    try {
        const saveProduct = await csvUpload.save();
        res.send('success');
    } catch (err) {
        res.status(400).send(err);
        console.log(err);
    }
});


router.post('/subscribeShopperrProduct/', async (req, res) => {

    const { customerEmail = "", skus = "", getDetail = 0, unsubscribe = 0, margin = 75, is_draft = 0,merchantId=null,channel=""} = req.body
    if ((!customerEmail && !merchantId) || !skus || margin < 30 || margin > 400) {
        return res.send({ error: 1, message: "Invalid Params" });
    }
    try {
        let merchant = null;
        if(merchantId){
          merchant = await MerchantUser.findOne({ "_id": mongoose.Types.ObjectId(merchantId) });
        } else {
          merchant = await MerchantUser.findOne({ "email": customerEmail });
        }
        if (!merchant) {
            return res.send({ error: 1, message: 'Merchant did not find' });
        }

        let products = await Products.find({ $or: [{ 'code': { $in: skus } }, { 'vd.sku': { $in: skus } }] }, { code: 1,'vd.sku':1 });
        if (!products || (products && !products.length)) {
            return res.send({ error: 1, message: 'Product did not find' });
        }

        if (getDetail && Array.isArray(skus)) {
            let subSkus = [];
            let prodIds = products.map(x=>{
                subSkus[x.code] = x._id;
                if(x.vd.length){
                    x.vd.forEach(el=>{
                        subSkus[el.sku] = x._id;
                    })
                }
               return  x._id
            });
            
            let sprod = [];
            if (merchant.amazonStoreData && merchant.amazonStoreData.length) {
                let asproduct = await AmazonSubscribeProducts.find({ pId: { $in :prodIds}, mId: merchant._id },{pId:1});
                if (asproduct && asproduct.length) {
                    asproduct.forEach((prod)=>{
                            sprod[prod.pId] = 1;
                    })
                    return res.send({ error: 0, data: skus.filter((sku)=>{
                        return sprod[subSkus[sku]];
                    })});
                } 
            }
            if (merchant.storeData && merchant.storeData.length) {
                let sproduct = await SubscribeProducts.find({ pId: { $in: prodIds}, mId: merchant._id },{pId:1});
                if (sproduct && sproduct.length) {
                    sprod = [];
                    sproduct.forEach((prod)=>{
                        sprod[prod.pId] = 1;
                    })
                    return res.send({ error: 0, data: skus.filter((sku)=>{
                        return sprod[subSkus[sku]];
                    })});
                } 
            }
            let sproducts = await ShopperrSubscribeProducts.find({ $and: [{ sku: { $in: skus }, mId: merchant._id, status: 0 }] }, { sku: 1, _id: 0 });
            sproducts = sproducts.map((item) => { return item.sku; });
            return res.send({ error: 0, data: sproducts });
        }

        const updates = (await Promise.all(products.map((product) => {
            return (new Promise(async (resolve, reject) => {
                try {
                    if (merchant.amazonStoreData && merchant.amazonStoreData.length) {
                        let asproduct = await AmazonSubscribeProducts.findOne({ pId: product._id, mId: merchant._id });
                        if (!asproduct) {
                            const amazonSubscribeProduct = await new AmazonSubscribeProducts({
                                mId: merchant._id,
                                pId: product._id,
                                dos: new Date(),
                                dom: new Date(),
                                margin: margin,
                                channel
                            });
                            await amazonSubscribeProduct.save();
                        } else if (asproduct.am_status != 0 || unsubscribe == 1) {
                            let amStatus = unsubscribe == 1 ? 3 : 0;
                            await AmazonSubscribeProducts.updateMany({ pId: product._id, mId: merchant._id }, { $set: { "am_status": amStatus,channel} });
                        }
                    }

                    if (merchant.storeData && merchant.storeData.length) {
                        let sproduct = await SubscribeProducts.findOne({ pId: product._id, mId: merchant._id });
                        if (!sproduct) {
                            const subscribeProducts = await new SubscribeProducts({
                                mId: merchant._id,
                                pId: product._id,
                                dos: new Date(),
                                dom: new Date(),
                                margin: margin,
                                channel
                            });
                            await subscribeProducts.save();
                        } else if (sproduct.su_status != 0 || unsubscribe == 1) {
                            let suStatus = unsubscribe == 1 ? 3 : 0;
                            await SubscribeProducts.updateMany({ pId: product._id, mId: merchant._id }, { $set: { "su_status": suStatus, margin: margin,channel } });
                        }
                    }

                    let ssproduct = await ShopperrSubscribeProducts.findOne({ pId: product._id, mId: merchant._id });
                    if (!ssproduct) {
                        const shopperrSubscribeProducts = await new ShopperrSubscribeProducts({
                            mId: merchant._id,
                            pId: product._id,
                            dos: new Date(),
                            dom: new Date(),
                            sku: product.code,
                            margin: margin,
                            [mongooseConstantValues.SUBSCRIBE_AS_DRAFT]: (is_draft ? 1 : 0),
                            channel
                        });
                        await shopperrSubscribeProducts.save();
                    } else if (ssproduct.status != 0 || unsubscribe == 1) {
                        let ssStatus = unsubscribe == 1 ? 3 : 0;
                        await ShopperrSubscribeProducts.updateMany({ pId: product._id, mId: merchant._id }, { $set: { "status": ssStatus,channel } });
                    }
                    resolve(product.code);
                } catch (err) {
                    reject(err);
                }
            }));

        })).then((data) => data).catch((err) => { throw err; }));

        return res.send({ error: 0, message: "Product Subscribed Successfully." });

    } catch (err) {
        console.log(err, "errerr");
        return res.send({ error: 1, message: err.toString() });
    }
});

router.post('/subscribeProduct/', async (req, res) => {
    const { customerEmail = "", ids = "", getDetail = 0, unsubscribe = 0, margin = 75, is_draft = 0,merchantId=null,channel=""} = req.body
    if ((!customerEmail && !merchantId) || !ids || margin < 30 || margin > 400) {
        return res.send({ error: 1, message: "Invalid Params" });
    }
    try {
        let merchant = null;
        if(merchantId){
          merchant = await MerchantUser.findOne({ "_id": mongoose.Types.ObjectId(merchantId) });
        } else {
          merchant = await MerchantUser.findOne({ "email": customerEmail });
        }
        if (!merchant) {
            return res.send({ error: 1, message: 'Merchant did not find' });
        }
        let mIds = [...ids.map(x=>mongoose.Types.ObjectId(x))]; 
        let products = await Products.find({'_id':{ $in:  mIds}}, { code: 1});
        if (!products || (products && !products.length)) {
            return res.send({ error: 1, message: 'Product did not find' });
        }

        if (getDetail && Array.isArray(ids)) {
            let subIds = [];
            let prodIds = products.map(x=>{
                subIds.push(x._id);
               return  x._id
            });
            
            let sprod = [];
            if (merchant.amazonStoreData && merchant.amazonStoreData.length) {
                let asproduct = await AmazonSubscribeProducts.find({ pId: { $in :prodIds}, mId: merchant._id,am_status:0},{pId:1});
                if (asproduct && asproduct.length) {
                    asproduct.forEach((prod)=>{
                            sprod[prod.pId] = 1;
                    })
                    return res.send({ error: 0, data: subIds.filter((id)=>{
                        return sprod[id];
                    })});
                } 
            }
            if (merchant.storeData && merchant.storeData.length) {
                let sproduct = await SubscribeProducts.find({ pId: { $in: prodIds}, mId: merchant._id,su_status:0 },{pId:1});
                if (sproduct && sproduct.length) {
                    sprod = [];
                    sproduct.forEach((prod)=>{
                        sprod[prod.pId] = 1;
                    })
                    return res.send({ error: 0, data: subIds.filter((id)=>{
                        return sprod[id];
                    })});
                } 
            }
            let sproducts = await ShopperrSubscribeProducts.find({ $and: [{'_id':{ $in:  mIds}}, {mId: merchant._id, status: 0 }] }, { sku: 1, _id: 0 });
            sproducts = sproducts.map((item) => { return item.pId; });
            return res.send({ error: 0, data: sproducts });
        }
        const updates = (await Promise.all(products.map((product) => {
            return (new Promise(async (resolve, reject) => {
                try {
                    if (merchant.amazonStoreData && merchant.amazonStoreData.length) {
                        let asproduct = await AmazonSubscribeProducts.findOne({ pId: product._id, mId: merchant._id });
                        if (!asproduct) {
                            const amazonSubscribeProduct = await new AmazonSubscribeProducts({
                                mId: merchant._id,
                                pId: product._id,
                                dos: new Date(),
                                dom: new Date(),
                                margin: margin,
                                channel
                            });
                            await amazonSubscribeProduct.save();
                        } else if (asproduct.am_status != 0 || unsubscribe == 1) {
                            let amStatus = unsubscribe == 1 ? 3 : 0;
                            await AmazonSubscribeProducts.updateMany({ pId: product._id, mId: merchant._id }, { $set: { "am_status": amStatus,channel} });
                        }
                    }

                    if (merchant.storeData && merchant.storeData.length) {
                        let sproduct = await SubscribeProducts.findOne({ pId: product._id, mId: merchant._id });
                        if (!sproduct) {
                            const subscribeProducts = await new SubscribeProducts({
                                mId: merchant._id,
                                pId: product._id,
                                dos: new Date(),
                                dom: new Date(),
                                margin: margin,
                                channel
                            });
                            await subscribeProducts.save();
                        } else if (sproduct.su_status != 0 || unsubscribe == 1) {
                            let suStatus = unsubscribe == 1 ? 3 : 0;
                            await SubscribeProducts.updateMany({ pId: product._id, mId: merchant._id }, { $set: { "su_status": suStatus, margin: margin,channel } });
                        }
                    }

                    let ssproduct = await ShopperrSubscribeProducts.findOne({ pId: product._id, mId: merchant._id });
                    if (!ssproduct) {
                        const shopperrSubscribeProducts = await new ShopperrSubscribeProducts({
                            mId: merchant._id,
                            pId: product._id,
                            dos: new Date(),
                            dom: new Date(),
                            sku: product.code,
                            margin: margin,
                            [mongooseConstantValues.SUBSCRIBE_AS_DRAFT]: (is_draft ? 1 : 0),
                            channel
                        });
                        await shopperrSubscribeProducts.save();
                    } else if (ssproduct.status != 0 || unsubscribe == 1) {
                        let ssStatus = unsubscribe == 1 ? 3 : 0;
                        await ShopperrSubscribeProducts.updateMany({ pId: product._id, mId: merchant._id }, { $set: { "status": ssStatus,channel } });
                    }
                    resolve(product.code);
                } catch (err) {
                    reject(err);
                }
            }));

        })).then((data) => data).catch((err) => { throw err; }));

        return res.send({ error: 0, message: unsubscribe == 1 ? "Product Unsubscribed Successfully." : "Product Subscribed Successfully." });

    } catch (err) {
        console.log(err, "errerr");
        return res.send({ error: 1, message: err.toString() });
    }
});

async function downloadProductCsvCronTab() {
    try { 
        let csvRequest = await CsvUpload.findOne({ "status": 0 , "type": 2 }); 
        // console.log(csvRequest , (csvRequest.page ? csvRequest.limit*(csvRequest.page-1) : 0) , csvRequest.limit);
        if(csvRequest) {
            let condition = JSON.parse(JSON.stringify(csvRequest.cond));
            let csvId = csvRequest._id;
            let csvProduct = await Products.find(condition[0] , {
                'subtitle' : 1 , 
                'name' : 1 , 
                'handle' : 1 , 
                'code' : 1 , 
                'price' : 1 , 
                'mrp' : 1 , 
                'quantity' : 1 , 
                'length' : 1 , 
                'width' : 1 , 
                'height' : 1 , 
                'weight' : 1 , 
                'hsn' : 1 , 
                'invoicedesc' : 1 , 
                'igst' : 1 , 
                'swcOnBcd' : 1 , 
                'margin' : 1 , 
                'varientArray' : 1 , 
                'supplier_id' : 1
            }).sort({ '_id': -1 }).skip((csvRequest.page ? csvRequest.limit*(csvRequest.page-1) : 0)).limit(100) 
            console.log(csvProduct.length);  
            // var csvProduct = await Products.find({ supplier_id: '602fbb6269fea1bd1b71bcbe' , varStatus : 4}).sort({'_id' : -1 });
            if(csvProduct.length > 0) {
                var supplierId = csvProduct[0].supplier_id; 
                let excelData = csvProduct.flatMap((product) =>{ 
                    if (product.subtitle == undefined) {
                        product.subtitle = '';
                    }
                    let excelObj = {
                        'id': String(product._id),
                        'title': product.name,
                        'Url': product.handle   == undefined ? '' : process.env.VIEW_PRODUCT_URL+'/product/'+product.handle,
                        'Sku': product.code     == undefined ? '' : product.code,
                        'Ex Factory Price': isNaN(product.price) ? '' : product.price,
                        'MRP': isNaN(product.mrp) ? '' : product.mrp,
                        'Quantity': product.quantity == undefined ? '' : product.quantity,
                        'Length': product.length == undefined ? '' : product.length,
                        'Width': product.width   == undefined ? '' : product.width,
                        'Height': product.height == undefined ? '' : product.height,
                        'Weight': product.weight == undefined ? '' : product.weight,
                        'Hsn': product.hsn == undefined ? '' : product.hsn,
                        'Subtitle': product.subtitle == undefined ? '' : product.subtitle,
                        'Invoicedesc': product.invoicedesc == undefined ? '' : product.invoicedesc,
                        'IGST': product.igst == undefined ? '' : product.igst,
                        'SWC on BCD': product.swcOnBcd == undefined ? '' : product.swcOnBcd,
                        'BCD': product.bcd == undefined ? '' : product.bcd,
                        'Margin': product.margin == undefined ? 40 : product.margin, 
                        'is_variant': '0',
                    }
                    return [excelObj,...(product.varientArray.length ? product.varientArray.map(function (variant) {
                        variantObj = JSON.parse(JSON.stringify(excelObj));
                        variantObj['Ex Factory Price'] = isNaN(variant.price) ? '' : variant.price;
                        variantObj['Sku'] = variant.sku == undefined ? '' : variant.sku;
                        variantObj['MRP'] = isNaN(variant.mrp) ? '' : variant.mrp;
                        variantObj['Quantity'] = variant.quantity == undefined ? '' : variant.quantity;
                        variantObj['is_variant'] = '1';
                        return variantObj;
                    }) : [])]
                });

                const csv = new ObjectsToCsv(excelData); 
                await csv.toDisk('./' + supplierId + '.csv').then(async () => {
                    var d = new Date();
                    const s3dir = "import_export/" + d.getFullYear().toString() + "/" + (d.getMonth() + 1).toString() + "/";
                    var filename = makeid(6) + '_' + supplierId + '.csv';
                    var fullPath = s3dir + filename;

                    const fileContent = fs.readFileSync('./' + supplierId + '.csv');
                    await uploadExcel(fileContent, s3dir + filename).then(async () => {
                        var url = process.env.S3_BUCKET_FILE_URL;
                        var obj = {
                            status: 1,
                            url: url + '/' + fullPath
                        }
                        try {
                            const data = await CsvUpload.updateOne({ "_id": csvId }, { $set: obj }, { upsert: false });
                            console.log("Update Result", data, url + '/' + fullPath);
                            var path = url + '/' + fullPath;
                            var transporter = nodemailer.createTransport({
                                service: 'gmail',
                                auth: {
                                    user: 'sellertesting0210@gmail.com',
                                    pass: 'Seller@12345',
                                },
                            });
                            var mailerHtml = '';
                            try {
                                mailerHtml = fs.readFileSync('./mail.html', 'utf8');
                                mailerHtml = mailerHtml.replace("{{click_me}}", path);

                            } catch (err) { }

                            var mailOptions = {
                                from: 'sellertesting0210@gmail.com',
                                to: 'agnihotrivivek529@gmail.com',
                                subject: 'Product Export',
                                html: mailerHtml,
                            };

                            transporter.sendMail(mailOptions, function (error, info) {
                                if (error) {
                                    console.log(err);
                                } else {
                                    console.log('Success'); 
                                }
                            });
                        } catch (err) {}
                        fs.unlink('./' + supplierId + '.csv', (err) => {
                            if (err) throw err;
                        });
                    });
                });
            }else{
                await CsvUpload.updateOne({ "_id": csvId }, { $set: {status:3} }, { upsert: false })
            }
        } else {
            console.log('No data');
        }
    } catch(err){
        throw err;
    }
    return false;
};

async function getCategoryTags(desc) {
    var category = await ShopperrCategory.find().exec();
    script.setDescription(desc);
    script.setCategory(category);
    return script.dataFindor();
}

script = new (function () {
    function ignoreCharacter() {
        return ['all', 'All', 'to', 'in', 'every', 'one', 'two', 'a'];
    }
    this.setDescription = function (des) {
        this.description = des.toLowerCase();
    }
    this.setCategory = function (obj) {
        this.data = obj;
    }
    this.dataFindor = function () {
        let categories = [];
        this.data.forEach((item, index) => {
            let keyworks = item.title.split(" ").map((str) => { return str.replace(" ", "") });
            keyworks.forEach((keyword) => {
                if (keyword.length > 3 && !ignoreCharacter().includes(keyword.toLowerCase())) {
                    if (this.description.search(keyword.toLowerCase()) > 0) {
                        categories.push(item.tag);
                    }
                }
            });
        });
        return categories;
    }
});
function updateSfcPriceAlgo(factory_price, pweight) {
    var STK_factory_price = factory_price;
    var lessCost = (STK_factory_price * 10 / 100);//120
    STK_factory_price = factory_price - lessCost;
    var exhangeCost = (STK_factory_price * 2 / 100);
    STK_factory_price = exhangeCost + STK_factory_price;
    var getDuty = STK_factory_price * 56 / 100;
    var getLandedCost = STK_factory_price + getDuty;
    var product_weight = pweight / 1000; // .005 
    var getFrieghtCost = (580 * product_weight * 1.18);
    var chaCost = 12;
    var processingCost = 12;
    var lastMileCost = 0;
    var getTotalCOCGS = getLandedCost + getFrieghtCost + chaCost + processingCost + lastMileCost;
    var profitAdd15Percent = (getTotalCOCGS * 1 / 100) + getTotalCOCGS;
    var gstImpact = (profitAdd15Percent - getTotalCOCGS) * 18 / 100;
    var gst_price = profitAdd15Percent + gstImpact;
    var product_msrp = gst_price * 2.5;
    var GSTPrice = gst_price.toFixed(2);
    var productPrice = product_msrp.toFixed(2);
    var totalCOCGS = getTotalCOCGS.toFixed(2);
    var data = { 'price': GSTPrice, 'cogs': totalCOCGS, 'mrp': productPrice }
    return data;
}

function updateQnuPriceAlgo(factoryPrice) {
    var cifValue = factoryPrice;
    var landedCost = (cifValue * 1 / 100);
    cifValue = cifValue + landedCost;
    var getDuty = cifValue * 25 / 100;
    var socialWelfareSurcharge = getDuty * 10 / 100;
    var priceBeforeGst = (cifValue + getDuty + socialWelfareSurcharge);
    var gst = priceBeforeGst * 18 / 100;
    var landedPrice = (cifValue + (cifValue * 50.5 / 100));
    var shopperrPrice = (landedPrice + (landedPrice * 43.89 / 100));
    var productMrp = shopperrPrice * 2;
    shopperrPrice = shopperrPrice.toFixed(2);
    var productPrice = productMrp.toFixed(2);
    var totalCOCGS = landedPrice.toFixed(2);
    var data = { 'price': shopperrPrice, 'cogs': totalCOCGS, 'mrp': productPrice }
    return data;
}


function seaPriceAlgo(factoryPrice, pweight, bcdRate, igstRate, swcRate) {
    var STK_factory_price = factoryPrice;  //120
    var insuranceCost = STK_factory_price * 1.125 / 100;
    var product_weight = pweight / 1000; // .005  
    var frieghtCostUsingWeight = (34.12 * product_weight);
    var percentageFrieghtCost = (STK_factory_price * 20 / 100);
    var cifValueOnWeight = STK_factory_price + insuranceCost + frieghtCostUsingWeight;
    var percentageCifValue = STK_factory_price + insuranceCost + percentageFrieghtCost;
    var assessableValue = (cifValueOnWeight < percentageCifValue) ? cifValueOnWeight : percentageCifValue;
    var bcdRate = bcdRate;
    var swcRate = swcRate;
    var igstRate = igstRate;
    var chaCost = 12;
    var getBcdRate = assessableValue * bcdRate / 100;
    var getSwcRate = (getBcdRate * swcRate / 100);
    var beforeGstPrice = (assessableValue + getBcdRate + getSwcRate + chaCost);
    var getGstRate = (beforeGstPrice * igstRate / 100);
    var getLandedCost = beforeGstPrice + getGstRate;
    var warehouseCharge = 2;
    var lastMileDeliveryRate = 16;
    var lastMileShiprocket = lastMileDeliveryRate * product_weight;
    var cogs = (getLandedCost + warehouseCharge + lastMileShiprocket);
    var shopperMargin = (cogs * 35 / 100);
    var priceAfterMarkup = cogs + shopperMargin;
    var gstImpact = (shopperMargin * 18 / 100);
    var sellingPrice = Math.ceil(priceAfterMarkup + gstImpact);
    var product_msrp = Math.ceil(sellingPrice * 2.5).toFixed(2);
    var totalCOCGS = cogs.toFixed(2);
    var data = { 'price': sellingPrice, 'cogs': totalCOCGS, 'mrp': product_msrp }
    return data;
}

function updateIndiaProductPriceAlgo(factoryPrice) {
    var factoryPrice = factoryPrice;  //120
    var shopperMargin = (factoryPrice * 15 / 100);
    var beforeGstPrice = factoryPrice + shopperMargin;
    var getGstRate = (beforeGstPrice * 12 / 100);
    var sellingPrice = (beforeGstPrice + getGstRate).toFixed(2);
    var product_msrp = (sellingPrice * 2.5).toFixed(2);
    var totalCOCGS = beforeGstPrice.toFixed(2);
    var data = { 'price': sellingPrice, 'cogs': totalCOCGS, 'mrp': product_msrp }
    return data;
}


function chinaPriceAlgo(factory_price, pweight) {
    var STK_factory_price = factory_price * 11.50;  //120
    var exhangeCost = (STK_factory_price * 2 / 100)
    STK_factory_price = exhangeCost + STK_factory_price;
    var getDuty = STK_factory_price * 35 / 100;
    var getLandedCost = STK_factory_price + getDuty;
    var product_weight = pweight / 1000; // .005 
    var getFrieghtCost = (312 * product_weight * 1.18);
    var chaCost = 12;
    var processingCost = 2;
    var lastMileCost = 0;
    var getTotalCOCGS = getLandedCost + getFrieghtCost + chaCost + processingCost + lastMileCost;
    var profitAdd15Percent = (getTotalCOCGS * 35 / 100) + getTotalCOCGS;
    var gstImpact = (profitAdd15Percent - getTotalCOCGS) * 18 / 100;
    var gst_price = profitAdd15Percent + gstImpact;
    var product_msrp = gst_price * 2.5;
    var GSTPrice = gst_price.toFixed(2);
    var productPrice = product_msrp.toFixed(2);
    var totalCOCGS = getTotalCOCGS.toFixed(2);
    var data = { 'price': GSTPrice, 'cogs': totalCOCGS, 'mrp': productPrice }
    return data;
}

function pricealgo(factory_price, pweight) {
    var STK_factory_price = Number(factory_price);  //120 
    var gst_impact = STK_factory_price * 18 / 100; // 67.2  
    var getTotalCOCGS = STK_factory_price - gst_impact;
    var product_msrp = STK_factory_price * 2.5;
    var GSTPrice = STK_factory_price.toFixed(2);
    var productPrice = product_msrp.toFixed(2);
    var totalCOCGS = getTotalCOCGS.toFixed(2);
    var data = { 'price': GSTPrice, 'cogs': totalCOCGS, 'mrp': productPrice }
    return data;
}


function getTagId(tags) {
    return new Promise(function (resolve, reject) {
        tagArr = []
        if (tags) {
            var tagsArray = tags.split(',');
            const promises = [];
            for (i = 0; i < tagsArray.length; i++) {
                var tag = tagsArray[i];
                promises.push(doSomeAsyncStuff(tag))
            }
            Promise.all(promises).then(tagArr => {
                // console.log(tagArr);
                resolve(tagArr);
            }).catch((e) => {
                // handle errors here
            });
        }
    })
}
function doSomeAsyncStuff(tag) {
    return new Promise(function (resolve, reject) {
        MainTag.find({ tag: tag }).limit(1).exec().then(if_tag => {
            if (if_tag) {
                if (if_tag[0]) {
                    resolve(if_tag[0]._id);
                } else {
                    const mainTag = new MainTag({ tag: tag });
                    mainTag.save().then(new_tag => {
                        resolve(new_tag._id);
                    })
                }
            }
        })
    })
}

async function generate_handle(title, callback) {
    var data = title.trim();
    var str = data.replace(/[^a-zA-Z0-9 ]/g, "");
    var str_lower = str.toLowerCase();
    var final_str = str_lower.replace(/ /g, "-");
    var handle = await Products.find({ "handle": final_str }).exec().then(product => {
        if (product == '') {
            return final_str;
        } else {
            return final_str + '-' + Date.now().toString();
        }
    });
    callback(handle);
}

function varientsArray(varients, productImage, handle) {
    return new Promise(function (resolve, reject) {
        varientsArr = []
        if (varients) {
            const promises = [];
            for (i = 0; i < varients.length; i++) {
                var varient = varients[i];
                var vrdata = varienttt(varient, productImage, handle);
                promises.push(vrdata);
            }
            Promise.all(promises).then(varientsArr => {
                resolve(varientsArr);
            }).catch((e) => {
                e
            });
        }
    })
}

function varienttt(varients, productImage, handle) {
    return new Promise(function (resolve, reject) {
        const varientId = new VarientId({ supplier_id: varients.product_id });
        varientId.save().then(result => {

            var mrp = '';
            if (varients.image_id != null) {
                var vrr = productImage.find(x => x.id === varients.image_id);
                if (vrr != '') {
                    var varient_id = '';
                    if (vrr.src != '') {
                        var imgData = { 'url': vrr.src, 'handle': handle };
                        var imgpath = '';
                        upload_image(imgData, function (result) {
                            imgpath = result;
                        });
                        var imgData = {
                            'position': varients.position,
                            'src': imgpath,
                            'varient_id': result._id
                        };
                    }
                }
            }

            var price = pricealgo(varients.price, varients.weight);
            if (varients.compare_at_price != '') {
                mrp = varients.compare_at_price;
            } else {
                mrp = price.mrp;
            }
            var varientdata = {
                'varient_id': result._id,
                'ShopifyVarientId': varients.id,
                'varient': varients.title,
                'price': Number(varients.price),
                'mrp': Number(mrp),
                'sp': Number(price.price),
                'cogs': Number(price.cogs),
                'quantity': varients.inventory_quantity,
                'sku': varients.sku,
                'selliingPrice': varients.price
            }
            var tgs = [];
            // tgs.push(varients.option1);
            // tgs.push(varients.option2);
            // tgs.push(varients.option3);
            var res1 = { 'Imagedata': imgData ? imgData : '', 'varient': varientdata, 'tags': tgs }
            resolve(res1); //   
        })
    })
}
async function upload_excel(handle, callback) {
    var d = new Date();//
    const imageDir = "images/" + d.getFullYear().toString() + "/" + (d.getMonth() + 1).toString() + "/" + handle.handle + "/";
    var s3dir = `${imageDir}`;
    var filename = Date.now().toString() + makeid(6) + '.png';
    var options = {
        uri: handle.url,
        encoding: null
    };
    request(options, async function (error, response, body) {
        if (error || response.statusCode !== 200) {
            console.log("failed to get image");
            console.log(error);
        } else {
            var status = await uploadFile(body, s3dir + filename);
        }
    });
    callback(s3dir + filename);
}

async function upload_image(handle, callback) {
    var d = new Date();//
    const imageDir = "images/" + d.getFullYear().toString() + "/" + (d.getMonth() + 1).toString() + "/" + handle.handle + "/";
    var s3dir = `${imageDir}`;
    var filename = Date.now().toString() + makeid(6) + '.png';
    var options = {
        uri: handle.url,
        encoding: null
    };
    request(options, async function (error, response, body) {
        if (error || response.statusCode !== 200) {
            console.log("failed to get image");
            console.log(error);
        } else {
            var status = await uploadFile(body, s3dir + filename);
        }
    });
    callback(s3dir + filename);
}
function makeid(length) {
    var result = '';
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}

async function assignAWBnumber() {
    try {
        Po.find({ $or: [{ awbNumber: { $exists: false } }, { awbNumber: null }] }).limit(constantValues.FETCH_PODATA_LIMIT)
            .then(async POResponse => {
                if (!_.isEmpty(POResponse)) {
                    await AWBNumber.find({ status: 0 }).limit(POResponse.length)
                        .then(async AWBNumberResponse => {
                            let ids = []
                            for (let i = 0; i < AWBNumberResponse.length; i++)
                                ids.push(AWBNumberResponse[i]._id)

                            await AWBNumber.update({ _id: { $in: ids } }, { $set: { status: 1 } }, { multi: true })
                                .then(async () => {
                                    for (let j = 0; j < POResponse.length; j++) {
                                        await Po.updateOne({ _id: POResponse[j]._id }, { $set: { awbNumber: AWBNumberResponse[j].awbkey } }, { new: true }).exec()
                                    }
                                })
                        })
                }
            })
    } catch (err) {
        console.log(err)
    }
}

async function getTokenFromXB() {
    try {
        Po.find({ $and: [{ paymentStatus: 1 }, { awbNumber: { $exists: true } }, { awbNumber: { $ne: null } }] })
            .then(poData => {
                let options = {
                    uri: "http://stageusermanagementapi.xbees.in/api/auth/generateToken",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer xyz"
                    },
                    body: JSON.stringify({
                        "username": "admin@shopperr.com",
                        "password": "$#Shop@202@",
                        "secretkey": "73d67a92a81290bfcd1455972d8bfbbbc87cf940c1d65c2618f56c17415ca944"
                    })
                }

                request.post(options)
                    .then(tokenResponse => {
                        let response = JSON.parse(tokenResponse)
                        if (response.code === 200) {
                            pushPoDataToXB(response.token, poData[0])
                        }
                    }).catch(err => console.log(err))
            })
    } catch (err) {
        console.log(err)

    }
}

async function pushPoDataToXB(token, poData) {
    let data = {
        "AirWayBillNO": poData.awbNumber,
        "OrderNo": poData.orderNumber,
        "BusinessAccountName": "shopperr",
        "ProductID": poData.productInfo.id,
        "Quantity": poData.qty,
        "ProductName": poData.productInfo.name,
        "ProductMRP": poData.price,
        "DropDetails": {
            "Addresses": [{
                "Type": "Primary",
                "Name": poData.customer.first_name + " " + poData.customer.last_name,
                "Address": poData.customer.default_address.address1,
                "City": poData.customer.default_address.city,
                "State": poData.customer.default_address.province,
                "PinCode": poData.customer.default_address.zip,
                "EmailID": poData.customer.email,
                "Landmark": "",
            }],
            "ContactDetails": [{
                "PhoneNo": poData.customer.default_address.phone,
                "Type": "Primary",
            }],
            "IsGenSecurityCode": "",
            "SecurityCode": "",
            "IsGeoFencingEnabled": false,
            "Latitude": "",
            "Longitude": "",
            "RediusLocation": 0.0,
            "MidPoint": 0.0,
            "MaxThresholdRadius": 0.0,
            "MinThresholdRadius": 0.0
        },
        "PickupDetails": {
            "Addresses": [{
                "Type": "Primary",
                "Name": "",
                "Address": "",
                "City": "",
                "State": "",
                "PinCode": "",
                "EmailID": "",
            }],
            "ContactDetails": [{
                "Type": "Primary",
                "PhoneNo": "",
                "VirtualNumber": ""
            }],
            "IsPickupPriority": 1,
            "PriorityRemarks": "",
            "PickupSlotsDate": "",
            "IsGenSecurityCode": "",
            "SecurityCode": "",
            "IsGeoFencingEnabled": "",
            "Latitude": "",
            "Longitude": "",
            "RediusLocation": "",
            "MaxThresholdRadius": "",
            "MinThresholdRadius": "",
            "MidPoint": ""
        },
        "PackageDetails": {
            "Dimensions": {

            },
            "Weight": {

            }
        }
    }

    let options = {
        uri: "http://api.staging.shipmentmanifestation.xbees.in/shipmentmanifestation/reverse",
        headers: {
            "Content-Type": "application/json",
            "token": token,
            "versionnumber": "v1",
        },
        body: JSON.stringify(data)
    }

    request.post(options)
        .then(response => {
            console.log(response)
        })
}

router.post('/updateVariantOnShopify/', async (req, res) => {
    let productId = req.body.productId;
    if (!productId) {
        return messageBuilder(res, 200, { ...req.body }, "Invalid Input Param mobile", { error: 1 });
    }
    let query = { "su_status": 1, pId: mongoose.Types.ObjectId(productId), su_status: 1, "spId": { $exists: true } };
    if (req.body.onShopper) {
        query.mId = mongoose.Types.ObjectId("600d67ca51b296e894178f3c");
    }
    const update = await SubscribeProducts.updateMany(query, { $set: { [mongooseConstantValues.IS_VARIANT_UPDATE]: 1 } });
    return messageBuilder(res, 200, { ...req.body }, "Update request processed successfully.", { error: 0, ...update });
});
async function updateVariantOnShopify(query = { "su_status": 1, [mongooseConstantValues.IS_VARIANT_UPDATE]: 1, "spId": { $exists: true } }) {
    let sproduct = await SubscribeProducts.findOne(query);
    if (!sproduct) {
        return { error: 1, message: "Product not subscribed." };;
    }

    let merchant = await MerchantUser.findOne({ "_id": sproduct.mId });
    if (!merchant) {
        return { error: 1, message: "merchant did not find." };
    }
    var updates = null;
    if (merchant.storeData && !merchant.storeData.length) {
        updates = await SubscribeProducts.updateMany({ "_id": sproduct._id }, { $set: { [mongooseConstantValues.IS_VARIANT_UPDATE]: 0 } });
        return { error: 1, message: "Please add Your Shopify API keys.", data: { merchant_id: merchant._id } };
    }
    let merchantInfo = merchant.storeData[0];

    let product = await Products.findOne({ "_id": sproduct.pId });
    if (!product || !sproduct.spId) {
        return { error: 1, message: "product did not find." };
    }
    let shopifyURl = "https://" + merchantInfo.shopifyApiKey + ":" + merchantInfo.shopifySecretKey + "@" + merchantInfo.storeDomain + "/admin/api/2021-01/products/" + sproduct.spId + "/variants.json";
    let updateOptionsURl = "https://" + merchantInfo.shopifyApiKey + ":" + merchantInfo.shopifySecretKey + "@" + merchantInfo.storeDomain + "/admin/api/2021-01/products/" + sproduct.spId + ".json";
    const shopRequestHeaders = {
        'X-Shopify-Access-Token': merchantInfo.shopifySecretKey,
        'Content-Type': 'application/json',
        'X-Shopify-Hmac-Sha256': merchantInfo.shopifyApiKey,
        'X-Shopify-Shop-Domain': merchantInfo.storeDomain,
        'X-Shopify-API-Version': '2021-01',
    };
    return request.get(shopifyURl)
        .then(async (data) => {
            try {
                var result = JSON.parse(data);
                if (!result || (result.variants && !result.variants.length)) {
                    result = { variants: [] };
                }
                let deleteVariant = [];
                let newVariant = [];

                var suppliers = await User.findOne({ _id: mongoose.Types.ObjectId(product.supplier_id) });
                let suppllierOrigin = '';
                if (suppliers) {
                    suppllierOrigin = suppliers.price_algo;
                }
                let fp = (product['price'] != undefined) ? product['price'] : 0;
                let mrps = (product.mrp != undefined) ? product.mrp : 0;
                let pw = (product.weight != undefined) ? product.weight : 0;
                let length = (product.length != undefined) ? product.length : 0;
                let width = (product.width != undefined) ? product.width : 0;
                let height = (product.height != undefined) ? product.height : 0;
                let pbcd = (product.bcd != undefined) ? product.bcd : 10;
                let pigst = (product.igst != undefined) ? product.igst : 18;
                let margin = (product.productMargin != undefined) ? product.productMargin : 40;
                let pswc = (product['swcOnBcd'] != undefined) ? product['swcOnBcd'] : 10;

                if (!product.vd) {
                    product.vd = [];
                }
                product.vd.forEach((item) => {
                    let variant = result.variants.find((ele) => {
                        return ele.sku == item.sku;
                    });
                    if (!variant) {
                        newVariant.push(item);
                    }
                });
 
                result.variants.forEach((item) => {
                    let variant = product.vd.find((ele) => {
                        return (ele.sku == item.sku);
                    });
                    if (!variant && item.sku != product.code) {
                        deleteVariant.push(item);
                    }
                });
                if(product.options && product.options.length){
                  let options = product.options.map((item)=>{ return {name:item.name,value:item.name} });
                  request.put(updateOptionsURl,{ headers: shopRequestHeaders, json: {
                    product:{
                      id:sproduct.spId,
                      options
                    }
                  }})
                  .then(async (data) => {}).catch(err=>{});
                }           

                let delay = 100;
                const addedNewVariants = (await Promise.all(newVariant.map((nVariant) => {
                    delay = delay+300;
                    return (new Promise(async (resolve, reject) => {
                      setTimeout(async ()=>{
                        if (!nVariant.sku) {
                            resolve({ error: 1 });
                            return false;
                        }
                        fp = (nVariant['price'] != undefined) ? nVariant['price'] : 0;
                        mrps = (nVariant.mrp != undefined) ? nVariant.mrp : 0;
                        let sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, length, width, height, mrps, margin);
                        let variantPrice = (sproduct.margin != undefined) && sproduct.margin ? Number(sp.airPrice.price) + (sp.airPrice.price * sproduct.margin / 100) : sp.airPrice.price;
                        let compare_at_price = parseFloat(sp.airPrice.mrp);
                        let cogs = parseFloat(sp.airPrice.cogs);
                        let msrp = getMsrp(compare_at_price);

                        var string = nVariant.varient.trim();
                        var array = string.split("/");
                        var [option1, option2, option3] = array;
                        let variantData = {
                            variant: {
                                option1: (option1 != undefined) ? option1 : '',
                                option2: (option2 != undefined) ? option2 : '',
                                option3: (option3 != undefined) ? option3 : '',
                                taxable: false,
                                sku: nVariant.sku,
                                price: Math.ceil(variantPrice),
                                cost: (sproduct.mId != '600d67ca51b296e894178f3c') ? sp.airPrice.price : cogs,
                                compare_at_price: (sproduct.mId != '600d67ca51b296e894178f3c') ? msrp : compare_at_price,
                                weight: product.weight ?? 0,
                                weight_unit: "g",
                                requires_shipping: true,
                                fulfillment_service: "manual",
                                inventory_management: "shopify"
                            }
                        };

                        request.post(shopifyURl, { headers: shopRequestHeaders, json: variantData })
                        .then(async (result) => {
                            if (!result || (result && !result.variant)) {
                                resolve({ error: 1, result: "Response not received." })
                                return false;
                            }
                            let variants = sproduct.vd;
                            variants.push({
                                spvid: result.variant.id,
                                ssvid: mongoose.Types.ObjectId(nVariant.varient_id)
                            });
                            var sproducts = await SubscribeProducts.updateMany({ "_id": sproduct._id }, { $set: { vd: variants } });
                            resolve({ error: 0, message: "New Variant added Successfully", varientId: nVariant.id, productId: product._id });
                        }).catch((err) => {
                            resolve({ error: 1, message: err.toString(), varientId: nVariant.varient_id, productId: product._id });
                        });
                      },delay)
                    }));
                })).then((data) => data).catch((err) => err));
                delay = 100;
                const deletedNewVariants = (await Promise.all(deleteVariant.map((dVariant) => {
                  delay = delay+300;
                    return (new Promise(async (resolve, reject) => {
                      setTimeout(async ()=>{
                        request.delete("https://" + merchantInfo.shopifyApiKey + ":" + merchantInfo.shopifySecretKey + "@" + merchantInfo.storeDomain + "/admin/api/2020-04/products/" + sproduct.spId + "/variants/" + dVariant.id + ".json")
                        .then(async (result) => {
                            let variants = sproduct.vd.filter((item) => {
                                let isAv = product.vd.find((ele) => {
                                    return (item.ssvid ? item.ssvid.toString() : item.ssvid)  == ele.varient_id;
                                });
                                return isAv ? 1 : 0;
                            });
                            var sproducts = await SubscribeProducts.updateMany({ "_id": sproduct._id }, { $set: { vd: variants } });
                            resolve({ error: 0, message: "Variant Delete Successfully", varientId: dVariant.id, productId: product._id });
                        }).catch((err) => {
                            resolve({ error: 1, message: err.toString(), varientId: dVariant.id, productId: product._id });
                        });
                      },delay);
                    }));
                })).then((data) => data).catch((err) => err));

                updates = await SubscribeProducts.updateMany({ "_id": sproduct._id }, { $set: { [mongooseConstantValues.IS_VARIANT_UPDATE]: 0 } });
                return { error: 0, data: { deletedNewVariants: JSON.stringify(deletedNewVariants), addedNewVariants:JSON.stringify(addedNewVariants) } };
            } catch (err) {
                throw err;
            }
        }).catch((err) => {
            return { error: 1, message: err.message };
        });
}

async function discountCode(priceRuleId, isActive) {
    let shopifyURl = "https://" + process.env.SHOPIFY_API_KEY.trim() + ":" + process.env.SHOPIFY_API_SECRET.trim() + "@" + process.env.SHOPIFY_API_DOMAIN.trim() + "/admin/api/2021-04/price_rules/" + priceRuleId + "/discount_codes.json";
    const shopRequestHeaders = {
        'X-Shopify-Access-Token': process.env.SHOPIFY_API_SECRET.trim(),
        'Content-Type': 'application/json',
        'X-Shopify-Hmac-Sha256': process.env.SHOPIFY_API_KEY.trim(),
        'X-Shopify-Shop-Domain': process.env.SHOPIFY_API_DOMAIN.trim(),
        'X-Shopify-API-Version': '2021-04',
    };
    request.get(shopifyURl, { headers: shopRequestHeaders })
        .then(async (data) => {
            var result = JSON.parse(data);
            if (!result || (result.discount_codes && !result.discount_codes.length)) {
                return false;
            }
            const updates = (await Promise.all(result.discount_codes.map((item) => {
                return (new Promise(async (resolve, reject) => {
                    let data = {};
                    data.id = item.id;
                    data[mongooseConstantValues.USAGE_COUNT] = item.usage_count;
                    data[mongooseConstantValues.DISCOUNT_CODE] = item.code;
                    data[mongooseConstantValues.PRICE_RULE_ID] = item.price_rule_id;
                    data[mongooseConstantValues.IS_ACTIVE] = isActive;
                    data[mongooseConstantValues.CREATED_ON] = new Date();
                    data[mongooseConstantValues.UPDATED_ON] = new Date();

                    let discountCode = await DiscountCode.findOne({ "id": item.id });
                    if (discountCode) {
                        await DiscountCode.updateMany({ "id": item.id }, { $set: data });
                    } else {
                        discountCode = await new DiscountCode(data);
                        await discountCode.save();
                    }
                }));
            })).then((data) => data).catch((err) => err));
        }).catch((err) => {
            throw err;
        });
}

async function discountCodeImportCorn() {
    let shopifyURl = "https://" + process.env.SHOPIFY_API_KEY.trim() + ":" + process.env.SHOPIFY_API_SECRET.trim() + "@" + process.env.SHOPIFY_API_DOMAIN.trim() + "/admin/api/2021-04/price_rules.json";
    const shopRequestHeaders = {
        'X-Shopify-Access-Token': process.env.SHOPIFY_API_SECRET.trim(),
        'Content-Type': 'application/json',
        'X-Shopify-Hmac-Sha256': process.env.SHOPIFY_API_KEY.trim(),
        'X-Shopify-Shop-Domain': process.env.SHOPIFY_API_DOMAIN.trim(),
        'X-Shopify-API-Version': '2021-04',
    };

    request.get(shopifyURl, { headers: shopRequestHeaders })
        .then(async (data) => {
            var result = JSON.parse(data);
            if (!result || (result.price_rules && !result.price_rules.length)) {
                return false;
            }
            const updates = (await Promise.all(result.price_rules.map((prule) => {
                return (new Promise(async (resolve, reject) => {
                    try {
                        let priceRule = await PriceRule.findOne({ "id": prule.id });

                        let data = {};
                        data.id = prule.id;
                        data[mongooseConstantValues.TITLE] = prule.title;
                        data[mongooseConstantValues.VALUE] = prule.value;
                        data[mongooseConstantValues.VALUE_TYPE] = prule.value_type;
                        data[mongooseConstantValues.CUSTOMER_SELECTION] = prule.customer_selection;
                        data[mongooseConstantValues.TARGET_TYPE] = prule.target_type;
                        data[mongooseConstantValues.TARGET_SELECTION] = prule.target_selection;
                        data[mongooseConstantValues.ALLOCATION_LIMIT] = prule.allocation_limit;
                        data[mongooseConstantValues.ONCE_PER_CUSTOMER] = prule.once_per_customer;
                        data[mongooseConstantValues.USEGE_LIMIT] = prule.usage_limit;
                        data[mongooseConstantValues.STARTS_AT] = prule.starts_at;

                        data[mongooseConstantValues.ENDS_AT] = prule.ends_at;
                        data[mongooseConstantValues.PREREQUISITE_SUBTOTAL_RANGE] = prule.prerequisite_subtotal_range;
                        data[mongooseConstantValues.PREREQUISITE_QUANTITY_RANGE] = prule.prerequisite_quantity_range;
                        data[mongooseConstantValues.PREREQUISITE_SHIPPING_PRICE_RANGE] = prule.prerequisite_shipping_price_range;

                        data[mongooseConstantValues.CREATED_ON] = new Date();
                        data[mongooseConstantValues.UPDATED_ON] = new Date();

                        let startsAt = (new Date(prule.starts_at)).getTime();
                        let endAt = (new Date(prule.ends_at)).getTime();
                        let isActive = 1;

                        if ((startsAt && (new Date()).getTime() < startsAt) || (endAt && (new Date()).getTime() > endAt)) {
                            isActive = 0;
                        }
                        await discountCode(prule.id, isActive);
                        if (priceRule) {
                            await PriceRule.updateMany({ "id": prule.id }, { $set: data });
                        } else {
                            priceRule = await new PriceRule(data);
                            await priceRule.save();
                        }
                        resolve({ price_rule_id: prule.id });
                    } catch (err) {
                        console.log(err, "err");
                        reject({ price_rule_id: prule.id, message: err.Message });
                        return false;
                    }
                }));
            })).then((data) => data).catch((err) => err));
        }).catch((err) => {
            console.log(err, "priceRule");
        });
}

const generateOtp = () => {
    return Math.floor(100000 + Math.random() * 900000);
};

const generateOtpUrl = (phoneno, otp) => {
    const sendOtpbaseUrl = process.env.OTP_BASE_URL;
    const otpMessage = `Your login OTP is ${otp} for www.shopperr.in. Do not share this OTP to anyone for security reasons. - Shopperr.in`;
    const sendOtpUrl = `${sendOtpbaseUrl}&Phno=${phoneno}&Msg=${otpMessage}`;
    const encodedSendOtpUrl = encodeURI(sendOtpUrl);
    return encodedSendOtpUrl;
};

//handle send otp for non registered
router.post('/sendotp/', async (req, res) => {
    const expectedSourceObj = { ios: 1, android: 2, web: 3 };
    const expectedSourceArr = Object.keys(expectedSourceObj);
    const phone = parseInt(req.body.mobile);
    const storeDomain = req.body.storeDomain;
    if (!phone) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param mobile");
    }
    const source = req.body.source;
    if (!source || !expectedSourceArr.includes(source.toLowerCase())) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param : source can not be null and should be one of value [android,ios,web]");
    }

    try {
        const customer = await Customer.findOne({ $and: [{ storeDomain: storeDomain, mobileNumber: phone }] });
        if (!customer) {
            return messageBuilder(res, 400, { ...req.body }, "mobile number is not registered.");
        }

        const createdVerficiation = await sendMobileOtp(phone, source);
        if (createdVerficiation && createdVerficiation._id) {
            return messageBuilder(res, 200, { ...req.body }, "Otp sent successfully");
        } else {
            return messageBuilder(res, 500, { ...req.body }, "Could not handle your request , please try after some time");
        }
    } catch (err) {
        return messageBuilder(res, 500, { ...req.body }, err);
    }
});

async function sendMobileOtp(phone, source) {
    const otp = generateOtp();
    const otpUrl = generateOtpUrl(phone, otp);
    const responseOtg = await axios.get(otpUrl);
    const { Status, Response } = responseOtg.data;
    if (Status !== "OK")
        return false;

    const otpVerification = new OtpVerification({
        m: phone,
        src: source,
        otp,
    });
    return await otpVerification.save();
}

async function sendEmailOtp(email, source) {
  const otp = generateOtp();
  var transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
          user: 'sellertesting0210@gmail.com',
          pass: 'Seller@12345',
      },
  });
  var mailerHtml = '';
  mailerHtml = fs.readFileSync('./emailTemplates/otp-template.html', 'utf8');
  mailerHtml = mailerHtml.replace("{{login_otp}}", otp).replace("{{login_datetime}}", new Date().toString()).replace("{{login_ip}}", ip.address());
  var mailOptions = {
      from: 'sellertesting0210@gmail.com',
      to: email,
      subject: 'Email Verification',
      html: mailerHtml,
  };
  await transporter.sendMail(mailOptions).then((result)=>result).catch((err)=>{throw err});
  const otpVerification = new OtpVerification({
      em: email,
      src: source,
      otp,
  });
  return await otpVerification.save();
}

//handle verify otp for non registered
router.post('/verifyotp/', async (req, res) => {
    const expectedSourceObj = { ios: 1, android: 2, web: 3 };
    const expectedSourceArr = Object.keys(expectedSourceObj);
    const phone = parseInt(req.body.mobile);
    const otp = parseInt(req.body.otp);
    const storeDomain = req.body.storeDomain;
    if (!phone || !otp || !storeDomain) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param mobile");
    }
    const source = req.body.source;
    if (!source || !expectedSourceArr.includes(source.toLowerCase())) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param : source can not be null and should be one of value [android,ios,web]");
    }

    try {
        const customer = await Customer.findOne({ $and: [{ storeDomain: storeDomain, mobileNumber: phone }] });
        if (!customer) {
            return messageBuilder(res, 400, { ...req.body }, "mobile number is not registered.");
        }

        const otpVerificationFindbyMobile = await verifyMobileOtp(phone, otp);
        if (!otpVerificationFindbyMobile) {
            return messageBuilder(res, 404, { ...req.body }, "Invalid OTP");
        }
        let secretKey = process.env.MULTIPASS_SHOPPERR_SECRET.trim();
        if(storeDomain === "cld-furniture.myshopify.com"){
            secretKey = process.env.MULTIPASS_CLD_SECRET.trim();
        }   
        var multipassify = new Multipassify(secretKey);
        // Create your customer data hash
        var customerData = { email: customer.email };

        // Encode a Multipass token
        var token = multipassify.encode(customerData);

        // Generate a Shopify multipass URL to your shop
        var url = multipassify.generateUrl(customerData, storeDomain);
        return messageBuilder(res, 200, { ...req.body }, "Verified Successfully", { url, error: 0 });
    } catch (err) {
        return messageBuilder(res, 500, { ...req.body }, err.toString());
    }
});

async function verifyEmailOtp(email, otp) {
    // const otpVerificationFindbyMobile = await OtpVerification.findOne({ m: phone }).sort({ createdAt: -1 });
    let expireTime = new Date(new Date().getTime() - 5000);
    const otpVerificationFindbyMobile = await OtpVerification.findOne({ em: email, "createdAt": { $lt: expireTime } }).sort({ createdAt: -1 });
    if (!otpVerificationFindbyMobile || (otpVerificationFindbyMobile && otpVerificationFindbyMobile.otp != otp)) {
        return false;
    }
    otpVerificationFindbyMobile.status = true;
    return await otpVerificationFindbyMobile.save();
}

async function verifyMobileOtp(phone, otp) {
    // const otpVerificationFindbyMobile = await OtpVerification.findOne({ m: phone }).sort({ createdAt: -1 });
    let expireTime = new Date(new Date().getTime() - 5000);
    const otpVerificationFindbyMobile = await OtpVerification.findOne({ m: phone, "createdAt": { $lt: expireTime } }).sort({ createdAt: -1 });
    if (!otpVerificationFindbyMobile || (otpVerificationFindbyMobile && otpVerificationFindbyMobile.otp != otp)) {
        return false;
    }
    otpVerificationFindbyMobile.status = true;
    return await otpVerificationFindbyMobile.save();
}

router.post('/addDropshipperOrders', async function (req, res) {
    var orderdata = req.body.orderData;
    var orderRecord = await Order.find({ "orderId": orderdata.orderId , "storeDomain" : "dropshipper.shopperr.in"});
    if (orderRecord.length == 0) {
        let custCond = { 'customerId': orderdata.extra.customer_id }
        let customerdata = await getCustomerData(custCond);
        if (customerdata) {
            let customerId = customerdata._id;
            let merchantId = customerdata.merchantId;
            let products = (await Promise.all(orderdata.product.map((product) => {
                return (new Promise(async (resolve, reject) => {
                    let productId = await Products.findOne({ code: product.sku }, { _id: 1 });
                    if (productId == null) {
                        product.id = '';
                    } else {
                        product.id = productId._id;
                    }
                    resolve(product)
                }));
            })).then((data) => data).catch((err) => err));
            let merCond = { '_id': merchantId }
            let merchantData = await getmerchantData(merCond);
            if (merchantData) {
                let orderCustomer = orderdata.customer;
                let orderBillingAddress = orderdata.billingAddress;
                orderCustomer.default_address.address1 = merchantData.address ? merchantData.address : orderCustomer.default_address.address1;
                orderCustomer.default_address.city = merchantData.city ? merchantData.city : orderCustomer.default_address.city;
                orderCustomer.default_address.zip = merchantData.pincode ? merchantData.pincode : orderCustomer.default_address.zip;
                orderCustomer.default_address.province = merchantData.state ? merchantData.state : orderCustomer.default_address.province;
                orderBillingAddress.address1 = merchantData.address ? merchantData.address : orderBillingAddress.address1;
                orderBillingAddress.city = merchantData.city ? merchantData.city : orderBillingAddress.city;
                orderBillingAddress.zip = merchantData.pincode ? merchantData.pincode : orderBillingAddress.zip;
                orderBillingAddress.province = merchantData.state ? merchantData.state : orderBillingAddress.province;
                orderBillingAddress.country = merchantData.country ? merchantData.country : orderBillingAddress.country;
                const orders = new Order({
                    merchantId: merchantId,
                    storeDomain: orderdata.storeDomain,
                    orderId: orderdata.orderId,
                    orderSerial: orderdata.orders_serial,
                    price: orderdata.customer.price,
                    currency: 'INR',
                    created_on: new Date(),
                    products: orderdata.product,
                    orderNumber: orderdata.orderId,
                    customer: orderCustomer,
                    varient: orderdata.varient,
                    fulfillmentStatus: orderdata.fulfillmentStatus,
                    tracking_number: orderdata.tracking_number,
                    pStatus: orderdata.pStatus,
                    updated_on: new Date(),
                    paymentDetails: orderdata.paymentDetails,
                    billingAddress: orderBillingAddress,
                    shippingAddress: orderdata.shippingAddress,
                    otherData: orderdata.extra
                });
                let orderResponse = await orders.save().then((orderResponse) => {
                    var orderResponse = { 'OrderId': orderResponse._id, 'MongoOrderId': orderResponse.orderId, 'Response': 'Order save successfully' };
                    res.send(orderResponse);
                });
            } else {
                res.send('Merchant Not found');
            }
        } else {
            res.send('Customer Not found');
        }
    } else {
        res.send('Order Already Exists');
    }
});
router.post('/addCustomers', async function (req, res) {
    var customerdata = req.body.customerData;
    var customerRecord = await Customer.find({ "customerId": customerdata.customer_id });
    if (customerRecord.length == 0) {
        const salt = await bcrypt.genSalt(10);
        const hashPassword = await bcrypt.hash('Merchant@12345', salt);
        const data = new Customer({
            storeDomain: 'dropshipper.shopperr.in',
            customerId: customerdata.customer_id,
            loginID: customerdata.customer_logid,
            email: customerdata.email,
            firstName: customerdata.customer_firstname,
            lastName: customerdata.customer_lastname,
            phone: customerdata.customer_telephone,
            companyName: customerdata.customer_company_name,
            gstNumber: customerdata.gstin_code,
            mobileNumber: customerdata.customer_telephone,
            rawData: customerdata.otherDetail
        });
        var customerResponse = await saveCustomerData(data, customerdata, hashPassword);
        res.send(customerResponse);
    } else {
        res.send('Customer Already Exist.');
    }
    return false;
});

function saveCustomerData(data, customerdata, hashPassword) {
    return new Promise((resolve, reject) => {
        try {
            data.save().then((result) => {
                const merchantUser = new MerchantUser({
                    customerId: result._id,
                    firstName: customerdata.customer_firstname,
                    lastName: customerdata.customer_lastname,
                    phoneNo: customerdata.customer_telephone,
                    email: customerdata.email,
                    gstNumber: customerdata.gstin_code,
                    password: hashPassword
                });
                merchantUser.save().then((merchantResult) => {
                    Customer.updateOne({ "_id": result._id }, { $set: { merchantId: merchantResult._id } }, { upsert: false }).then((updatedata) => {
                        var merResponse = { 'customerId': result._id, 'merchantId': merchantResult._id, 'Response': updatedata }
                        resolve(merResponse);
                    });
                });
            });
        } catch (err) {
            console.log(err);
            return true;
        }
    })
}

router.post('/send-mobile-otp/', async (req, res) => {
    const expectedSourceObj = { ios: 1, android: 2, web: 3 };
    const expectedSourceArr = Object.keys(expectedSourceObj);
    const phone = parseInt(req.body.mobile);
    const shop = req.body.shop;
    if (!phone) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param mobile");
    }
    const source = req.body.source;
    if (!source || !expectedSourceArr.includes(source.toLowerCase())) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param : source can not be null and should be one of value [android,ios,web]");
    }

    try {
        const customer = await Customer.findOne({ $and: [{ storeDomain: shop, mobileNumber: phone }] });
        if (customer) {
            return messageBuilder(res, 400, { ...req.body }, "mobile number is already registered.");
        }

        const createdVerficiation = await sendMobileOtp(phone, source);
        if (createdVerficiation && createdVerficiation._id) {
            return messageBuilder(res, 200, { ...req.body }, "Otp sent successfully");
        } else {
            return messageBuilder(res, 500, { ...req.body }, "Could not handle your request , please try after some time");
        }
    } catch (err) {
        return messageBuilder(res, 500, { ...req.body }, err.toString());
    }
});

router.post('/verify-mobile-otp/', async (req, res) => {
    const expectedSourceObj = { ios: 1, android: 2, web: 3 };
    const expectedSourceArr = Object.keys(expectedSourceObj);
    const phone = parseInt(req.body.mobile);
    const otp = parseInt(req.body.otp);
    const storeDomain = req.body.storeDomain;
    if (!phone || !otp) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param mobile");
    }
    const source = req.body.source;
    if (!source || !expectedSourceArr.includes(source.toLowerCase())) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param : source can not be null and should be one of value [android,ios,web]");
    }

    try {
        const otpVerificationFindbyMobile = await verifyMobileOtp(phone, otp);
        if (!otpVerificationFindbyMobile) {
            return messageBuilder(res, 404, { ...req.body }, "Invalid OTP");
        }
        return messageBuilder(res, 200, { ...req.body }, "Verified Successfully");
    } catch (err) {
        return messageBuilder(res, 500, { ...req.body }, err.toString());
    }
});

function getCustomerData(cond) {
    return new Promise((resolve, reject) => {
        try {
            let customerData = Customer.findOne(cond);
            resolve(customerData);
        } catch (err) {
            return true;
        }
    })
}
function getmerchantData(cond) {
    return new Promise((resolve, reject) => {
        try {
            let merData = MerchantUser.findOne(cond);
            resolve(merData);
        } catch (err) {
            reject(err);
        }
    })
}
// router.post('/updateProductIgstCron' , async function (req , res) {  
async function updateProductIgstCron() {
    let products = await Hsnmasters.find({ isUpdate: { $exists: false } }).limit(10);
    // let products = await Hsnmasters.find({"istore_product_id" : 63003866}); 
    if (products.length > 0) {
        const updates = (await Promise.all(products.map((product) => {
            return (new Promise(async (resolve, reject) => {
                let isProducts = await Products.find({ code: product.istore_product_id }, { _id: 1 });
                if (isProducts.length > 0) {
                    var updateObj = {
                        hsn: product.hsn,
                        igst: product.gst,
                        bcd: product.bcd,
                        invoicedesc: product.description
                    }
                    try {
                        Products.updateOne({ "code": product.istore_product_id }, { $set: updateObj }, { upsert: false }).then((updateresponse) => {
                            Hsnmasters.updateOne({ "_id": product._id }, { $set: { isUpdate: 1 } }, { upsert: false }).then(() => {
                                resolve({ 'error': 0, 'message': 'Product Igst updated againest these Sku : ' + product.istore_product_id + ' ', updateresponse, 'Hsn Id': product._id, 'Object': updateObj });
                            });
                        });
                    } catch (err) {
                        resolve({ 'error': 1, 'message': err });
                    }
                } else {
                    Hsnmasters.updateOne({ "_id": product._id }, { $set: { isUpdate: 2 } }, { upsert: false }).then(() => {
                        resolve({ 'error': 1, 'message': 'Product Not Found with ' + product.istore_product_id + ' Sku.' });
                    });
                }
            }));
        })).then((data) => data).catch((err) => err));
    } else {
        console.log('All product Igst updated');
    }
};


router.get('/subscribed-by-shopperr/', async (req, res) => {
    const _id = req.query.productId;
    if (!_id) {
        return messageBuilder(res, 400, { ...req.query }, "Invalid Input Param mobile");
    }
    try {
        const sproduct = await SubscribeProducts.find({ mId: mongoose.Types.ObjectId("600d67ca51b296e894178f3c"), pId: mongoose.Types.ObjectId(_id) }).sort({ "su_status": -1 }).limit(1);
        if (!sproduct || (sproduct && !sproduct.length)) {
            return messageBuilder(res, 404, { ...req.query }, "Product not Subscribed.");
        }
        return messageBuilder(res, 200, { ...req.query }, "Verified Successfully", { data: sproduct[0] });
    } catch (err) {
        return messageBuilder(res, 500, { ...req.query }, err);
    }
});

router.post('/upload-on-shopperr/', async (req, res) => {
    const _id = req.body.productId;
    if (!_id) {
        return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param mobile");
    }
    try {
        let sproduct = await SubscribeProducts.findOne({ mId: mongoose.Types.ObjectId("600d67ca51b296e894178f3c"), pId: mongoose.Types.ObjectId(_id) });
        if (!sproduct) {
            return messageBuilder(res, 404, { ...req.body }, "Product not Subscribed.");
        }
        await addShopifyProducts([sproduct], 0);
        return messageBuilder(res, 200, { ...req.body }, "Request submitted for upload product.", sproduct);
    } catch (err) {
        return messageBuilder(res, 500, { ...req.body }, err);
    }
});


router.post('/updateDropshipperOrders', async function (req, res) {
    var orderdata = req.body.orderData;
    var orderRecord = await Order.findOne({ "orderId": orderdata.orders_id , "storeDomain" : "dropshipper.shopperr.in"});
    if (orderRecord) {
        let poids = [];
        orderRecord.invoicePo.forEach(async function (po) {
            let poId = po.purchaseOrderId
            poids.push(poId);
        });
        let condition = {
            '_id': { $in: poids },
            'sku': orderdata.sku
        }
        let poInfo = await getPO(condition);
        if (poInfo) {
            let obj = {
                updatedAt: new Date(),
                orderStatus: orderdata.orders_status,
                opStatus: orderdata.orders_status_payment,
                orReason: orderdata.order_refund_reason,
                oshipStatus: orderdata.orders_status_shipping,
                orStatus: orderdata.orders_status_return,
                odStatus: orderdata.orders_status_dispute,
                ocStatus: orderdata.orders_status_comment,
                omStatus: orderdata.orders_status_mail,
                orFee: orderdata.order_refund_fee,
                rtFee: orderdata.refund_transaction_fee,
                cancelTime: orderdata.cancel_time,
                refundTime: orderdata.refund_time,
                trackingNo: orderdata.os_tracking_no,
                deliverDate: orderdata.os_date_deliver,
                dispatchDate: orderdata.os_date_add,
                shipApplyStatus: orderdata.os_apply_status,
                shipApplyModiDate: orderdata.os_apply_modi_date,
                carrierName: orderdata.carrier_name,
                carrierId: orderdata.carrier_id,
                shipComment: orderdata.os_comment,
                shipMethod: orderdata.shipping_method,
                systemComment: orderdata.system_comment,
                dispatchDate : orderdata.os_date_add
            }
            Po.updateOne({ "_id": poInfo._id }, { $set: obj }, { upsert: false }).then((response) => {
                var orderResponse = { 'PO OrderId': poInfo._id, 'Response': 'Order Updated successfully' };
                res.send(orderResponse);
            })
        } else {
            res.send({ 'error': 1, 'message': 'No po data found' });
        }
    } else {
        res.send({ 'error': 1, 'message': 'Order Not Found with ' + orderdata.orders_id + ' Order Id.' });
    }
});


router.post('/updateDropshipperOrdersTest', async function (req, res) {
    var orderdata = req.body.orderData; 
    var orderRecord = await Order.findOne({ "orderId": orderdata.orders_id , "storeDomain" : "dropshipper.shopperr.in"});
    if (orderRecord) { 
        let obj = { 
            products : orderdata.product,
            invoicePo : [],
            poProcess : 0,
            poFlag : 'false',
            isDelete : 'false' 
        } 
        Order.updateOne({ "_id": orderRecord._id }, { $set: obj }, { upsert: false }).then((response) => {
            var orderResponse = { 'PO OrderId': orderRecord._id, 'Response': 'Order Updated successfully' };
            res.send(orderResponse);
        }) 
    } else {
        res.send({ 'error': 1, 'message': 'Order Not Found with ' + orderdata.orders_id + ' Order Id.' });
    }
});

function getPO(cond) {
    return new Promise((resolve, reject) => {
        try {
            let poData = Po.findOne(cond);
            resolve(poData);
        } catch (err) {
            return true;
        }
    })
}

router.post('/createLabels', async (req, res) => {
    let labeldata = req.body.label;
    let data = new LogisticsLabel({
        'awbNo': labeldata.awbNo,
        'label': labeldata.label,
        'createdDate': new Date()
    });
    try {
        data.save().then((result) => {
            res.send({ 'Status': 1, 'Message': 'Label created success.' })
        });
    } catch (err) {
        res.send({ 'Status': 0, 'Message': 'Something went wrong.' });
    }

});
async function getoffshelfCron() {
    let page = 0;
    let pageinfo = await Offshelfpage.findOne().sort({ '_id': -1 });
    if (pageinfo) {
        page = pageinfo.pageNo;
    }
    page = page + 1;
    let response = await new Promise((resolve, reject) => {
        try {
            let shopifyURl = 'https://admin.chinafulfill.com/sub-system/get-india-order-pickup?params={"header":{"warehouseId":"9","cooperationId":"1","token":"TUlJQ1hnSUJBQUtCZ1FDd04=","key":"TUlJQ1hnSUJBQUtCZ1FDd05zc3M="},"data":{"is_labelling":[0,2],"opi_add_time_from":"null","opi_add_time_to":"null","page":' + page + ',"page_size":30,"warehouse_id":"9"}}';
            const shopRequestHeaders = {
                'Content-Type': 'application/json'
            };
            request.post(shopifyURl, { headers: shopRequestHeaders }).then(async (data) => {
                let response = JSON.parse(data);
                if (response.data) {
                    let insertPage = new Offshelfpage({
                        'pageNo': page,
                        'created_at': new Date(),
                        'updated_at': new Date()
                    });
                    let res = await insertPage.save();
                    const updates = (await Promise.all(Object.keys(response.data).map((order) => {
                        return (new Promise(async (resolve, reject) => {
                            let IsOrderoffshelf = await Orderoffshelf.findOne({ 'refOrder': order });
                            if (!IsOrderoffshelf) {
                                let offshelfdata = new Orderoffshelf({
                                    'refOrder': order,
                                    'orderDetail': response.data[order],
                                    'created_at': new Date,
                                    'updated_at': new Date,
                                });
                                offshelfdata.save().then(() => {
                                    resolve({ 'error': 0, 'Message': 'Offshelf created success with id : ' + order, offshelfdata });
                                });
                            } else {
                                resolve({ 'error': 1, 'Message': 'Offshelf already exists with id : ' + order, IsOrderoffshelf });
                            }
                        }));
                    })).then((data) => data).catch((err) => err));
                } else {
                    console.log('errrr', response.data, response.status);
                }
            }).catch((err) => {
                resolve(err);
            });
        } catch (err) {
            resolve(err);
        }
    });
}

router.post('/updateProductIgstCron1' , async function (req , res) {  
    var options = {
        uri: 'https://logistics.shopperr.in/img/pdflabels_1/1001VZL4PS0000__14361700045.pdf',
        encoding: null
    };
    request(options, async function (error, response, body) {
        if (error || response.statusCode !== 200) {
            console.log("failed to get image");
            console.log(error);
        } else {
            console.log(body);
            var d = new Date();
            const imageDir = "label/" + d.getFullYear().toString() + "/" + (d.getMonth() + 1).toString() +  "/";
            var s3dir = `${imageDir}`;
            var filename = Date.now().toString() + makeid(6) + '.pdf';
            var result = await uploadPdf(body, s3dir + filename);
            console.log(result , s3dir + filename); 
        }
    }); 
});
 
async function uploadPdf(file, key){ 
    const params = {
        Bucket: process.env.S3_FILE_BUCKET,
        Key: key, // File name you want to save as in S3
        Body: file,
        ContentEncoding: 'base64',
        ContentType : 'application/pdf'
    } 
    s3.upload(params, (err, data) => {
        if(err) console.log("error", err)
        else console.log(`Pdf uploaded successfully. ${data.Location} , ${data}`);
    })
}

router.post('/gethtml' , async function (req , res) {  
    pdf2html.pages('https://static-staging-sellercentral.shopperr.in/label/2021/6/1623752091459dZK6zO.pdf', (err, html) => {
        if (err) {
            console.error('Conversion error: ' + err)
        } else {
            console.log(html)
        }
    })
});
// router.post('/updateProductIgstCron' , async function (req , res) {  
async function updateMerchantAddressCron() {
    let merchant = await MerchantUser.find({ gstNumber: { $exists: false },  "store" : "shopperr2.myshopify.com" }).limit(20);
    // let products = await Hsnmasters.find({"istore_product_id" : 63003866}); 
    if (merchant.length > 0) {
        const updates = (await Promise.all(merchant.map((mer) => {
            return (new Promise(async (resolve, reject) => {
                let isCustomer = await Customer.find({ "email" : mer.email , "storeDomain" : "shopperr2.myshopify.com" });
                if (isCustomer.length > 0) {
                    var updateObj = {
                        gstNumber: isCustomer['0'].gstNumber,
                        companyName : isCustomer['0'].companyName 
                    }
                    try {
                        MerchantUser.updateOne({ "_id": mer._id }, { $set: updateObj }, { upsert: false }).then((updateresponse) => {
                            resolve({ 'error': 0, 'message': 'Merchant Gst updated. Email : '+ mer.email +' .'   , 'Object': updateObj });
                        });
                    } catch (err) {
                        resolve({ 'error': 1, 'message': err });
                    }
                } else {
                    resolve({ 'error': 1, 'message': 'Customer Not Found.' });
                }
            }));
        })).then((data) => data).catch((err) => err));
    } else {
        console.log('All Merchant updated');
    }
};
router.post('/set-notification' , async function (req , res) {  
    try {
        var message = { //this may vary according to the message type (single recipient, multicast, topic, et cetera)
            to: 'fLpsFP5zTp6UyYgVcGd5TI:APA91bHIR0lNIgjCJfaf0nE60p8EdqcYDu06IrmrpJg579Idfz9ODhD6ai1iY9S5Hvob4WmnlDuoQjZKONgCr4NavL8imJH82k-0o5tqVzV7rOb0LRI2p3zhCq5itMp_EkXxG0omDLXB',             
            notification: {
                title: 'Title of your push notification', 
                body: 'Body of your push notification' 
            },
            
            data: {  //you can send only notification or only data(or include both)
                my_key: 'my value',
                my_another_key: 'my another value'
            }
        }

        var fcm = new FCM(process.env.FIREBASE_SERVER_KEY);
        fcm.send(message, function(err, response){
            if (err) {
                console.log("Something has gone wrong!");
            } else {
                console.log("Successfully sent with response: ", JSON.stringify(response));
            }
        });
        return res.send("done ");
    } catch(err){
        return res.send({error:err.toString()});
    }
});

router.post('/sendemail/', async (req, res) => {
  const expectedSourceObj = { ios: 1, android: 2, web: 3 };
  const expectedSourceArr = Object.keys(expectedSourceObj);
  const email = req.body.email;
  const storeDomain = req.body.storeDomain;
  if (!email) {
      return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param email");
  }
  const source = req.body.source;
  if (!source || !expectedSourceArr.includes(source.toLowerCase())) {
      return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param : source can not be null and should be one of value [android,ios,web]");
  }

  try {
      const merchant = await MerchantUser.findOne({ email: email });
      if (!merchant) {
          return messageBuilder(res, 400, { ...req.body }, "email is not registered.");
      }
      const createdVerficiation = await sendEmailOtp(email, source);
      if (createdVerficiation && createdVerficiation._id) {
          return messageBuilder(res, 200, { ...req.body }, "Otp sent successfully");
      } else {
          return messageBuilder(res, 500, { ...req.body }, "Could not handle your request , please try after some time");
      }
  } catch (err) {
      return messageBuilder(res, 500, { ...req.body }, err);
  }
});

router.post('/verifyemailotp/', async (req, res) => {
  const expectedSourceObj = { ios: 1, android: 2, web: 3 };
  const expectedSourceArr = Object.keys(expectedSourceObj);
  const email = req.body.email;
  const otp = parseInt(req.body.otp);
  const shop = req.body.shop;
  if (!email || !otp || !shop) {
      return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param email");
  }
  const source = req.body.source;
  if (!source || !expectedSourceArr.includes(source.toLowerCase())) {
      return messageBuilder(res, 400, { ...req.body }, "Invalid Input Param : source can not be null and should be one of value [android,ios,web]");
  }
  try {
      const merchant = await MerchantUser.findOne({ email: email });
      if (!merchant) {
          return messageBuilder(res, 400, { ...req.body }, "email is not registered.");
      }
      const otpVerificationFindbyMobile = await verifyEmailOtp(email, otp);
      if (!otpVerificationFindbyMobile) {
          return messageBuilder(res, 404, { ...req.body }, "Invalid OTP");
      }
      let userInfo = {
		id: merchant._id,
		email: merchant.email,
		category: merchant.category,
		store: merchant.store,
	}
	const token = jwt.sign(userInfo, process.env.TOKEN_SECRET)
	merchant.tokens.push({ access: auth, token })
    return messageBuilder(res, 200, { ...req.body }, "Verified Successfully", {error: 0,token});
  } catch (err) {
      return messageBuilder(res, 500, { ...req.body }, err.toString());
  }
});

async function updateSubCategories(){
    let AllCategories = await MainCategory.find({});
    fs.writeFile('allcategories.json', JSON.stringify(AllCategories), function (err) {
        if (err) throw err;
        console.log('Saved!');
    });
    let categories  = await MainCategory.find({code:{$exists:true},parent_id:{$exists:false}},{code:true,bno:true});
    let nodeIds = categories.map((item)=>item.code);
    let browseNodes = categories.map((item)=>item.bno);
    
    categoriesData = {};
    AllCategories.forEach((item)=>{
      categoriesData[item.bno] = item;
      categoriesData[item.code] = item;
      categoriesData[item._id] = item;
    });
  
    let nodes  = await BrowseNodes.find({cc:{$in:nodeIds} });
    // let paths = [];
    // let subcat = {};
    // let counter = 0;

    // nodes.forEach((node)=>{
    //   if(!subcat[node.cc]){
    //     subcat[node.cc] = {
    //       cat:"",
    //       subcat:[],
    //     }
    //   }
    //   let path = node.path.split("/");
    //   if(node.cc == 22 && node.path == "Industrial & Scientific"){
    //     paths.push(path);
    //     console.log(path,"path");
    //   }
    //   if(path.length == 1){
    //     subcat[node.cc].cat = node.node;
    //   } else {
    //     subcat[node.cc].subcat.push(node.node);
    //     counter++;
    //   }
    // });

    let subCategories = [];
    nodes.forEach( async (node)=>{
      let subcat = node.path.split("/");
      if(categoriesData[node.cc].bno == node.node && subcat.length == 1){
        await MainCategory.updateOne({_id:categoriesData[node.cc]._id},{$set:{level:1}});
        return false
      }
      if(categoriesData[node.node.toString()]){
        return false;
      }
      subCategories.push({
        category:subcat[subcat.length - 1],
        bno:node.node,
        code:node.cc,
        parent_id: categoriesData[node.cc]._id,
        updatedOn:new Date().toISOString(),
        created_on:new Date().toISOString(),
        description:subcat[subcat.length - 1],
        level: subcat.length
      })
    });
    
    let updates = await MainCategory.insertMany(subCategories);
    return updates;
  }

  router.post('/getSubscribedProducts/', async (req, res) => {
    const { customerEmail = "",merchantId=null} = req.body
    let {limit=50,page=1} = req.body
    if ((!customerEmail && !merchantId)) {
        return res.send({ error: 1, message: "Invalid Params" });
    }
    try {
        let merchant = null;
        if(merchantId){
          merchant = await MerchantUser.findOne({ "_id": mongoose.Types.ObjectId(merchantId) });
        } else {
          merchant = await MerchantUser.findOne({ "email": customerEmail });
        }
        if (!merchant) {
            return res.send({ error: 1, message: 'Merchant did not find' });
        }

        page = parseInt(page);
        limit = parseInt(limit);
        const startIndex = (page - 1) * limit;
        const endIndex = page * limit;
        const results = {};
        let query = [
            {   
                mId: merchant._id,
            },
            {
                status: 0
            }
        ];
       
        const productCount = await ShopperrSubscribeProducts.countDocuments({$and: query}).exec();
        results.count = productCount;
        results.startIndex = startIndex;
        if (endIndex < productCount) {
          // console.log(productCount);
          results.next = {
            page: page + 1,
            limit: limit,
          };
        }
        if (startIndex > 0) {
          results.previous = {
            page: page - 1,
            limit: limit,
          };
        }

        let sproducts = await ShopperrSubscribeProducts.find({$and: query}, { 
            sku: 1, _id: 0
        }).sort({ _id: -1 })
        .limit(limit)
        .skip(startIndex)
        .exec();
        let skus = sproducts.map((item) => { 
            return item.sku; 
        });
        let products = await Products.find({ $or: [{ 'code': { $in: skus } }, {'varientArray.sku': { $in: skus } }] }, {code: 1,name:1,handle:1,imgUrl:1,productMargin:1,supplier_id:1,price:1,weight:1,length:1,width:1, height:1,bcd:1,igst:1,productMargin:1,swcOnBcd:1 });
        let productIds = [];
        results.products = (await Promise.all(products.map((product) => {
            return (new Promise(async (resolve, reject) => {
                productIds.push(product._id);
                let suppliers = await User.findOne({ _id: mongoose.Types.ObjectId(product.supplier_id) });
                let suppllierOrigin = '';
                let supplier_id = 'Shopperr'; 
                if (suppliers) {
                    suppllierOrigin = suppliers.price_algo;
                    supplier_id = suppliers.supplier_id;
                }
                let sprod = await SubscribeProducts.findOne({pId:product._id,mId:mongoose.Types.ObjectId("611dd6963f897a8f2921d8fa") }, {spId: 1, _id: 0});

                let fp = (product.price != undefined) ? product.price : 0;
                let mrps = (product.mrp != undefined) ? product.mrp : 0;
                let pw = (product.weight != undefined) ? product.weight : 0;
                let lenght = (product.length != undefined) ? product.length : 0;
                let width = (product.width != undefined) ? product.width : 0;
                let height = (product.height != undefined) ? product.height : 0;
                let pbcd = (product.bcd != undefined) ? product.bcd : 10;
                let pigst = (product.igst != undefined) ? product.igst : 18;
                let margin = (product.productMargin != undefined) ? product.productMargin : 40;
                let pswc = (product.swcOnBcd != undefined) ? product.swcOnBcd : 10;
                let sp = await updateShopperrPriceAlgo(Number(fp), Number(pw), suppllierOrigin, pbcd, pigst, pswc, lenght, width, height, mrps, margin);

                variantPrice = parseFloat(sp.airPrice.price);
                compare_at_price = parseFloat(sp.airPrice.mrp);
                cogs = parseFloat(sp.airPrice.cogs);
                msrp = getMsrp(compare_at_price);
                let finalPrice = (product.margin != undefined) ? Number(variantPrice) + (variantPrice * product.margin / 100) : variantPrice;
         
                return resolve({
                    displayPrice:Math.ceil(finalPrice),
                    handle:product.handle,
                    name:product.name,
                    code:product.code,
                    imgUrl:(product.imgUrl.length ? process.env.S3_BUCKET_FILE_URL+'/'+product.imgUrl[0].src : ""),
                    spId: sprod ? sprod.spId : "sdf"
                });
            }));
        })).then((data) => data).catch((err) => err));
        

        if (!products || (products && !products.length)) {
            return res.send({ error: 1, message: 'Product did not find' });
        }
        return res.send({ error: 0, message: "Product Subscribed Successfully.",results});
    } catch (err) {
        console.log(err, "errerr");
        return res.send({ error: 1, message: err.Message });
    }
});

router.post('/shopperHandle', async (req, res) => {
    const _id = req.body.id;
    if (!_id) {
        return res.status(500).send({ error: 1,message: "Invalid Input Param"});
    }
    try {
        let merchant = await MerchantUser.findOne({ "_id": mongoose.Types.ObjectId("611dd6963f897a8f2921d8fa") });
        let shopifyURl = "https://" + merchant.storeData[0].storeDomain + "/admin/api/2021-07/products/"+_id+".json?fields=handle";
        const shopRequestHeaders = {
            'X-Shopify-Access-Token': merchant.storeData[0].shopifySecretKey,
            'Content-Type': 'application/json',
            'X-Shopify-Hmac-Sha256': merchant.storeData[0].shopifyApiKey,
            'X-Shopify-Shop-Domain': merchant.storeData[0].storeDomain,
            'X-Shopify-API-Version': '2021-07',
        };
    
        let resp = await request.get(shopifyURl, { headers: shopRequestHeaders })
            .then(data => JSON.parse(data)).catch(err=>{
                throw err;
            })
        return res.send({ error: 0,redirect_url:'https://global.shopperr.in/products/'+resp.product.handle});
    } catch (err) {
        return res.status(500).send({ error: 1,message:err.toString()});
    }
});

router.get('/currency-rates', async (req, res) => {
    try {
        fs.readFile(__dirname.replace("/routes","")+'/config/currencyRates.json',async (err,data) =>{
            if (err) return res.status(500).send({ error: 1,message:err.toString()});
            let date = new Date().toISOString();
            data = JSON.parse(data.toString());
            if(new Date(data.date).getTime() != new Date(date.split("T")[0]).getTime()){
                let res = await axios.get('https://v1.nocodeapi.com/shubhambabu/cx/yBJPpDjXHYWCquoe/rates?source=INR').then((result)=>result).catch((err)=>{
                    console.log(err);
                    return data;
                });
                if(!res.data) return false;
                let dt = res.data.date.split("-")
                if(dt[2].length === 1) {
                    dt[2] = "0"+dt[2];
                }
                if(dt[1].length === 1) {
                    dt[1] = "0"+dt[1];
                }
                res.data.date = dt.join("-")
                fs.writeFile(__dirname.replace("/routes","")+'/config/currencyRates.json', JSON.stringify(res.data), function (err) {
                    if (err) throw err;
                    console.log('Saved!');
                });
            }
            return res.status(200).send(data);
        });
    } catch (err) {
        return res.status(500).send({ error: 1,message:err.toString()});
    }
});

module.exports = router;
